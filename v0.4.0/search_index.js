var documenterSearchIndex = {"docs":
[{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Thank you for considering contributing to CalibrateEDMF! We encourage opening issues and pull requests (PRs).","category":"page"},{"location":"contributing/#What-to-contribute?","page":"Contributing","title":"What to contribute?","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The easiest way to contribute is by using CalibrateEDMF, identifying problems and opening issues;\nYou can try to tackle an existing issue. It is best to outline your proposed solution in the issue thread before implementing it in a PR;\nWrite an example or tutorial. It is likely that other users may find your use of CalibrateEDMF insightful;\nImprove documentation or comments if you found something hard to use;\nImplement a new feature if you need it. We strongly encourage opening an issue to make sure the administrators are on board before opening a PR with an unsolicited feature addition.","category":"page"},{"location":"contributing/#Using-git","page":"Contributing","title":"Using git","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you are unfamiliar with git and version control, the following guides will be helpful:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Atlassian (bitbucket) git tutorials. A set of tips and tricks for getting started with git.\nGitHub's git tutorials. A set of resources from GitHub to learn git.","category":"page"},{"location":"contributing/#Forks-and-branches","page":"Contributing","title":"Forks and branches","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Create your own fork of CalibrateEDMF on GitHub and check out your copy:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git clone https://github.com/<your-username>/CalibrateEDMF.jl.git\n$ cd CalibrateEDMF.jl","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Now you have access to your fork of CalibrateEDMF through origin. Create a branch for your feature; this will hold your contribution:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git checkout -b <branchname>","category":"page"},{"location":"contributing/#Some-useful-tips","page":"Contributing","title":"Some useful tips","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"When you start working on a new feature branch, make sure you start from main by running: git checkout main and git pull.\nCreate a new branch from main by using git checkout -b <branchname>.","category":"page"},{"location":"contributing/#Develop-your-feature","page":"Contributing","title":"Develop your feature","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Make sure you add tests for your code in test/ and appropriate documentation in the code and/or in docs/. Before committing your changes, you can verify their behavior by running the tests, the examples, and building the documentation locally. In addition, make sure your feature follows the formatting guidelines by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"julia --project=.dev .dev/climaformat.jl .","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"from the CalibrateEDMF.jl directory.","category":"page"},{"location":"contributing/#Squash-and-rebase","page":"Contributing","title":"Squash and rebase","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"When your PR is ready for review, clean up your commit history by squashing and make sure your code is current with CalibrateEDMF.jl main by rebasing. The general rule is that a PR should contain a single commit with a descriptive message.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To make sure you are up to date with main, you can use the following workflow:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git checkout main\n$ git pull\n$ git checkout <name_of_local_branch>\n$ git rebase main","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This may create conflicts with the local branch. The conflicted files will be outlined by git. To resolve conflicts, we have to manually edit the files (e.g. with vim). The conflicts will appear between >>>>, ===== and <<<<<. We need to delete these lines and pick what version we want to keep.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To squash your commits, you can use the following command:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git rebase -i HEAD~n","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"where n is the number of commits you need to squash into one. Then, follow the instructions in the terminal. For example, to squash 4 commits:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git rebase -i HEAD~4","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"will open the following file in (typically) vim:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"   pick 01d1124 <commit message 1>\n   pick 6340aaa <commit message 2>\n   pick ebfd367 <commit message 3>\n   pick 30e0ccb <commit message 4>\n\n   # Rebase 60709da..30e0ccb onto 60709da\n   #\n   # Commands:\n   #  p, pick = use commit\n   #  e, edit = use commit, but stop for amending\n   #  s, squash = use commit, but meld into previous commit\n   #\n   # If you remove a line here THAT COMMIT WILL BE LOST.\n   # However, if you remove everything, the rebase will be aborted.\n##","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We want to keep the first commit and squash the last 3. We do so by changing the last three commits to squash and then do :wq on vim.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"   pick 01d1124 <commit message 1>\n   squash 6340aaa <commit message 2>\n   squash ebfd367 <commit message 3>\n   squash 30e0ccb <commit message 4>\n\n   # Rebase 60709da..30e0ccb onto 60709da\n   #\n   # Commands:\n   #  p, pick = use commit\n   #  e, edit = use commit, but stop for amending\n   #  s, squash = use commit, but meld into previous commit\n   #\n   # If you remove a line here THAT COMMIT WILL BE LOST.\n   # However, if you remove everything, the rebase will be aborted.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Then in the next screen that appears, we can just delete all messages that we do not want to show in the commit. After this is done and we are back to  the console, we have to force push. We need to force push because we rewrote the local commit history.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git push -u origin <name_of_local_branch> --force","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"You can find more information about squashing here.","category":"page"},{"location":"contributing/#Unit-testing","page":"Contributing","title":"Unit testing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Currently a number of checks are run per commit for a given PR.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"JuliaFormatter checks if the PR is formatted with .dev/climaformat.jl.\nDocumentation rebuilds the documentation for the PR and checks if the docs are consistent and generate valid output.\nUnit Tests run subsets of the unit tests defined in tests/, using Pkg.test(). The tests are run in parallel to ensure that they finish in a reasonable time. The tests only run the latest commit for a PR, branch and will kill any stale jobs on push. These tests are only run on linux (Ubuntu LTS).","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Unit tests are run against every new commit for a given PR, the status of the unit-tests are not checked during the merge process but act as a sanity check for developers and reviewers. Depending on the content changed in the PR, some CI checks that are not necessary will be skipped.  For example doc only changes do not require the unit tests to be run.","category":"page"},{"location":"contributing/#The-merge-process","page":"Contributing","title":"The merge process","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We use bors to manage merging PR's in the the CalibrateEDMF repo. If you're a collaborator and have the necessary permissions, you can type bors try in a comment on a PR to have integration test suite run on that PR, or bors r+ to try and merge the code.  Bors ensures that all integration tests for a given PR always pass before merging into main. The integration tests currently run example cases in examples/. Any breaking changes will need to also update the examples/, else bors will fail.","category":"page"},{"location":"API/ReferenceStats/#ReferenceStats","page":"ReferenceStats","title":"ReferenceStats","text":"","category":"section"},{"location":"API/ReferenceStats/","page":"ReferenceStats","title":"ReferenceStats","text":"CurrentModule = CalibrateEDMF.ReferenceStats","category":"page"},{"location":"API/ReferenceStats/","page":"ReferenceStats","title":"ReferenceStats","text":"ReferenceStatistics\nget_obs\nobs_PCA\npca\npca_length\nfull_length\nget_profile\nget_time_covariance","category":"page"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.ReferenceStatistics","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.ReferenceStatistics","text":"ReferenceStatistics{FT <: Real, IT <: Integer}\n\nA structure containing statistics from the reference model used to define a well-posed inverse problem.\n\nFields\n\ny::Vector{FT} where FT<:Real\nReference data, length: nSim * nvars * nzLevels (possibly reduced by PCA)\nΓ::Matrix{FT} where FT<:Real\nData covariance matrix, dims: (y,y) (possibly reduced by PCA)\nnorm_vec::Array{Vector{FT}, 1} where FT<:Real\nVector (length: nSim) of normalizing factors (length: n_vars)\npca_vec::Array{Union{LinearAlgebra.UniformScaling, Matrix{FT}}, 1} where FT<:Real\nVector (length: nSim) of PCA projection matrices with leading eigenvectors as columns\ny_full::Vector{FT} where FT<:Real\nFull reference data vector, length: nSim * n_vars * n_zLevels\nΓ_full::SparseArrays.SparseMatrixCSC{FT, Int64} where FT<:Real\nFull covariance matrix, dims: (y,y)\nndof_case::Vector{IT} where IT<:Integer\nDegrees of freedom per case (possibly reduced by PCA)\nndof_full_case::Vector{IT} where IT<:Integer\nFull degrees of freedom per case\n\nConstructors\n\nReferenceStatistics(y::Vector{FT}, args...) where {FT <: Real}\nReferenceStatistics(\n    RM::Vector{ReferenceModel};\n    perform_PCA::Bool = true,\n    normalize::Bool = true,\n    variance_loss::FT = 0.1,\n    tikhonov_noise::FT = 0.0,\n    tikhonov_mode::String = \"absolute\",\n    dim_scaling::Bool = false,\n    y_type::ModelType = LES(),\n    Σ_type::ModelType = LES(),\n    Δt::FT = 6 * 3600.0,\n) where {FT <: Real}\n\nConstructs the ReferenceStatistics defining the inverse problem.\n\nInputs:\n\nRM               :: Vector of ReferenceModels.\nperform_PCA      :: Boolean specifying whether to perform PCA.\nnormalize        :: Boolean specifying whether to normalize the data.\nvariance_loss    :: Fraction of variance loss when performing PCA.\ntikhonov_noise   :: Tikhonov regularization factor for covariance matrices.\ntikhonov_mode    :: If \"relative\", tikhonov_noise is scaled by the maximum  eigenvalue in the covariance matrix considered, having the interpretation of  the inverse of the desired condition number. This value is enforced to be  larger than the sqrt of the machine precision for stability.\ndim_scaling      :: Whether to scale covariance blocks by their size.\ny_type           :: Type of reference mean data. Either LES() or SCM().\nΣ_type           :: Type of reference covariance data. Either LES() or SCM().\nΔt               :: [LES last time - SCM start time (LES timeframe)] for LES_driven_SCM cases.\n\n\n\n\n\n","category":"type"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.get_obs","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.get_obs","text":"get_obs(\n    m::ReferenceModel,\n    y_names::Vector{String},\n    Σ_names::Vector{String},\n    normalize::Bool;\n    z_scm::Union{Vector{FT}, Nothing} = nothing,\n)\nget_obs(\n    m::ReferenceModel,\n    y_type::Union{LES, SCM},\n    Σ_type::Union{LES, SCM},\n    normalize::Bool;\n    z_scm::Union{Vector{FT}, Nothing},\n)\n\nGet observations for variables y_names, interpolated to z_scm (if given), and possibly normalized with respect to the pooled variance.\n\nInputs:\n\nm            :: Reference model\ny_names      :: Names of observed fields from the ReferenceModel m.\nΣ_names      :: Names of fields used to construct covariances, may be different than y_names  if there are LES/SCM name discrepancies.\nnormalize    :: Whether to normalize the observations.\nz_scm        :: If given, interpolate LES observations to given levels.\ny_type       :: ModelType used to construct observations, ::LES or ::SCM.\ny_type       :: ModelType used to construct noise covariances, ::LES or ::SCM.\n\nOutputs:\n\ny            :: Mean of observations, possibly interpolated to z_scm levels.\nΣ            :: Observational covariance matrix, possibly pool-normalized.\npool_var     :: Vector of vertically averaged time-variance, one entry for each variable\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.obs_PCA","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.obs_PCA","text":"obs_PCA(y_mean, y_var, allowed_var_loss = 1.0e-1)\n\nPerform dimensionality reduction using principal component analysis on the variance y_var. Only eigenvectors with eigenvalues that contribute to the leading 1-allowed_var_loss variance are retained. Inputs:\n\ny_mean           :: Mean of the observations.\ny_var            :: Variance of the observations.\nallowed_var_loss :: Maximum variance loss allowed.\n\nOutputs:\n\ny_pca            :: Projection of y_mean onto principal subspace spanned by eigenvectors.\ny_var_pca        :: Projection of y_var on principal subspace.\nP_pca            :: Projection matrix onto principal subspace, with leading eigenvectors as columns.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.pca","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.pca","text":"pca(covmat::AbstractMatrix{FT}, allowed_var_loss::FT) where {FT <: Real}\n\nPerform dimensionality reduction using principal component analysis on the variance covmat.\n\nInputs:\n\ncovmat           :: Variance of the observations.\nallowed_var_loss :: Maximum variance loss allowed.\n\nOutputs:\n\nλ_pca            :: Principal eigenvalues, ordered in increasing value order.\nP_pca            :: Projection matrix onto principal subspace, with leading eigenvectors as columns.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.pca_length","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.pca_length","text":"Returns dimensionality of the ReferenceStatistics in low-dimensional latent space\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.full_length","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.full_length","text":"Returns full dimensionality of the ReferenceStatistics, before latent space encoding\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.get_profile","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.get_profile","text":"get_profile(\n    filename::String,\n    y_names::Vector{String};\n    ti::Real = 0.0,\n    tf = nothing,\n    z_scm::Union{Vector{FT}, Nothing} = nothing,\n)\nget_profile(m::ReferenceModel, filename::String; z_scm::Union{Vector{T}, T} = nothing) where {T}\nget_profile(\n    m::ReferenceModel,\n    filename::String,\n    y_names::Vector{String};\n    z_scm::Union{Vector{T}, T} = nothing,\n) where {T}\n\nGet time-averaged profiles for variables y_names, interpolated to z_scm (if given), and concatenated into a single output vector.\n\nInputs:\n\nfilename    :: nc filename\ny_names   :: Names of variables to be retrieved.\nti          :: Initial time of averaging window.\ntf          :: Final time of averaging window.\nz_scm       :: If given, interpolate LES observations to given levels.\nm           :: ReferenceModel from which to fetch profiles, implicitly defines ti and tf. \n\nOutputs:\n\ny :: Output vector used in the inverse problem, which concatenates the requested profiles.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.get_time_covariance","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.get_time_covariance","text":"get_time_covariance(m::ReferenceModel, y_names::Vector{String}; z_scm::Vector{FT}) where {FT <: Real}\n\nObtain the covariance matrix of a group of profiles, where the covariance is obtained in time.\n\nInputs:\n\nm            :: Reference model.\ny_names    :: List of variable names to be included.\nz_scm        :: If given, interpolates covariance matrix to this locations.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#TurbulenceConvectionUtils","page":"TurbulenceConvectionUtils","title":"TurbulenceConvectionUtils","text":"","category":"section"},{"location":"API/TurbulenceConvectionUtils/","page":"TurbulenceConvectionUtils","title":"TurbulenceConvectionUtils","text":"CurrentModule = CalibrateEDMF.TurbulenceConvectionUtils","category":"page"},{"location":"API/TurbulenceConvectionUtils/","page":"TurbulenceConvectionUtils","title":"TurbulenceConvectionUtils","text":"ModelEvaluator\nrun_SCM\nrun_reference_SCM\neval_single_ref_model\nrun_SCM_handler\ncreate_parameter_vectors\ngenerate_scm_input\nget_gcm_les_uuid\nprecondition","category":"page"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.ModelEvaluator","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.ModelEvaluator","text":"ModelEvaluator\n\nA structure containing the information required to perform a forward model evaluation at a given parameter vector.\n\nFields\n\nparam_cons::Vector{FT} where FT<:Real\nParameter vector in constrained (i.e. physical) space\nparam_names::Vector{String}\nParameter names associated with parameter vector\nref_models::Vector{CalibrateEDMF.ReferenceModels.ReferenceModel}\nVector of reference models\nref_stats::CalibrateEDMF.ReferenceStats.ReferenceStatistics\nReference statistics for the inverse problem\n\nConstructors\n\nModelEvaluator(param_cons, param_names, RM, RS)\n\ndefined at /home/runner/work/CalibrateEDMF.jl/CalibrateEDMF.jl/src/TurbulenceConvectionUtils.jl:50.\n\nModelEvaluator(; param_cons, param_names, ref_models, ref_stats)\n\n\n\n\n\n","category":"type"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.run_SCM","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.run_SCM","text":"run_SCM(\n    u::Vector{FT},\n    u_names::Vector{String},\n    RM::Vector{ReferenceModel},\n    RS::ReferenceStatistics;\n    error_check::Bool = false,\n    namelist_args = nothing,\n    failure_handler = \"high_loss\",\n) where {FT <: Real}\nrun_SCM(\n    ME::ModelEvaluator;\n    error_check::Bool = false,\n    namelist_args = nothing,\n    failure_handler = \"high_loss\",\n) where {FT <: Real}\n\nRun the single-column model (SCM) using a set of parameters and return the value of outputs defined in y_names, possibly after normalization and projection onto lower dimensional space using PCA.\n\nThe function also outputs a boolean diagnosing whether the requested SCM simulation failed.\n\nInputs:\n\nu               :: Values of parameters to be used in simulations.\nu_names         :: SCM names for parameters u.\nRM              :: Vector of ReferenceModels\nRS              :: reference statistics for simulation\nerror_check     :: Returns as an additional argument whether the SCM call errored.\nnamelist_args   :: Additional arguments passed to the TurbulenceConvection namelist.\nfailure_handler :: Method used to handle failed simulations.\n\nOutputs:\n\nsim_dirs    :: Vector of simulation output directories\ng_scm       :: Vector of model evaluations concatenated for all flow configurations.\ng_scm_pca   :: Projection of g_scm onto principal subspace spanned by eigenvectors.\nmodel_error :: Whether the simulation errored with the requested configuration.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.run_reference_SCM","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.run_reference_SCM","text":"run_reference_SCM(m::ReferenceModel; overwrite::Bool = false, run_single_timestep = true)\n\nRun the single-column model (SCM) for a reference model object using default parameters, and write the output to file.\n\nInputs:\n\nm                    :: A ReferenceModel.\noverwrite            :: if true, run TC.jl and overwrite existing simulation files.\nrun_single_timestep  :: if true, run only one time step.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.eval_single_ref_model","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.eval_single_ref_model","text":"eval_single_ref_model(\n    m_index::IT,\n    m::ReferenceModel,\n    RS::ReferenceStatistics,\n    u::Vector{FT},\n    u_names::Vector{String},\n    namelist_args = nothing,\n) where {FT <: Real, IT <: Int}\n\nRuns the single-column model (SCM) under a single configuration (i.e., ReferenceModel) using a set of parameters u, and returns the forward model evaluation in both the original and the latent PCA space.\n\nInputs:\n\nm_index       :: The index of the ReferenceModel within the overarching                  ref_models vector used to construct the ReferenceStatistics.\nm             :: A ReferenceModel.\nRS            :: reference statistics for simulation\nu             :: Values of parameters to be used in simulations.\nu_names       :: SCM names for parameters u.\nnamelist_args :: Additional arguments passed to the TurbulenceConvection namelist.\n\nOutputs:\n\nsim_dir     ::  Simulation output directory.\ng_scm       :: Forward model evaluation in original output space.\ng_scm_pca   :: Projection of g_scm onto principal subspace spanned by eigenvectors.\nmodel_error :: Whether the simulation errored with the requested configuration.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.run_SCM_handler","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.run_SCM_handler","text":"run_SCM_handler(\n    m::ReferenceModel,\n    tmpdir::String,\n    u::Array{FT, 1},\n    u_names::Array{String, 1},\n    namelist_args = nothing,\n) where {FT<:AbstractFloat}\n\nRun a case using a set of parameters u_names with values u, and return directory pointing to where data is stored for simulation run.\n\nInputs:\n\nm             :: Reference model\ntmpdir        :: Temporary directory to store simulation results in\nu             :: Values of parameters to be used in simulations.\nu_names       :: SCM names for parameters u.\nnamelist_args :: Additional arguments passed to the TurbulenceConvection namelist.\n\nOutputs:\n\noutput_dir   :: directory containing output data from the SCM run.\nmodel_error   :: Boolean specifying whether the simulation failed.\n\n\n\n\n\nrun_SCM_handler(\n    case_name::String,\n    out_dir::String;\n    u::Vector{FT},\n    u_names::Vector{String},\n    namelist::Union{Dict, Nothing} = nothing,\n    namelist_args::Union{Tuple, Nothing} = nothing,\n    uuid::String = \"01\",\n    les::Union{NamedTuple, String} = nothing,\n)\n\nRun a TurbulenceConvection.jl case and return directory pointing to where data is stored for simulation run.\n\nInputs:\n\ncase_name     :: case name\nout_dir       :: Directory to store simulation results in.\n\nOptional Inputs:\n\nu             :: Values of parameters to be used in simulations.\nu_names       :: SCM names for parameters u.\nnamelist      :: namelist to use for simulation.\nnamelist_args :: Additional arguments passed to the TurbulenceConvection namelist.\nuuid          :: uuid of SCM run\nles           :: path to LES stats file, or NamedTuple with keywords {forcingmodel, month, experiment, cfsitenumber} needed to specify path. \n\nOutputs:\n\noutput_dir   :: directory containing output data from the SCM run.\nmodel_error   :: Boolean specifying whether the simulation failed.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.create_parameter_vectors","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.create_parameter_vectors","text":"create_parameter_vectors(u_names::Vector{String}, u::Vector{FT}) where {FT <: AbstractFloat}\n\nGiven vector of parameter names and corresponding values, combine any vector components into single parameter vectors for input into SCM.\n\nInputs:\n\nu_names :: SCM names for parameters u, which may contain vector components.\nu :: Values of parameters to be used in simulations, which may contain vector components.\n\nOutputs:\n\nu_names_out :: SCM names for parameters u.\nu_out :: Values of parameters to be used in simulations.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.generate_scm_input","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.generate_scm_input","text":"generate_scm_input(\n    model_evaluators::Vector{ModelEvaluator{FT}},\n    outdir_path::String = pwd(),\n) where {FT <: AbstractFloat}\n\nWrites to file a set of ModelEvaluator used to initialize SCM evaluations at different parameter vectors, as well as their assigned numerical version.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.get_gcm_les_uuid","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.get_gcm_les_uuid","text":"get_gcm_les_uuid(\n    cfsite_number::Integer;\n    forcing_model::String,\n    month::Integer,\n    experiment::String,)\n\nGenerate unique and self-describing uuid given information about a GCM-driven LES simulation from Zhaoyi Shen, Akshay Sridhar, Zhihong Tan, Anna Jaruga, Tapio Schneider (2022).\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.precondition","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.precondition","text":"precondition(\n    param::Vector{FT},\n    priors,\n    ref_models::Vector{ReferenceModel},\n    ref_stats::ReferenceStatistics,\n    namelist_args = nothing;\n    counter::Integer = 0,\n    max_counter::Integer = 10,\n) where {FT <: Real}\n\nSubstitute parameter vector param by a parameter vector drawn from the same prior, conditioned on the forward model being stable.\n\nInputs:\n\nparam      :: A parameter vector that may possibly result in unstable  forward model evaluations (in unconstrained space).\npriors      :: Priors from which the parameters were drawn.\nref_models  :: Vector of ReferenceModels to check stability for.\nref_stats   :: ReferenceStatistics of the ReferenceModels.\nnamelist_args :: Arguments passed to the TC.jl namelist.\ncounter :: Accumulator tracking number of recursive calls to preconditioner.\nmax_counter :: Maximum number of recursive calls to the preconditioner.\n\nOutputs:\n\nnew_param :: A new parameter vector drawn from the prior, conditioned on simulations being stable (in unconstrained space).\n\n\n\n\n\nprecondition(ME::ModelEvaluator, priors)\n\nSubstitute the parameter vector of a ModelEvaluator by another one drawn from the given priors, conditioned on the forward model being stable.\n\nInputs:\n\nME          :: A ModelEvaluator.\npriors      :: Priors from which the parameters were drawn.\n\nOutputs:\n\nA preconditioned ModelEvaluator.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#DistributionUtils","page":"DistributionUtils","title":"DistributionUtils","text":"","category":"section"},{"location":"API/DistributionUtils/","page":"DistributionUtils","title":"DistributionUtils","text":"CurrentModule = CalibrateEDMF.DistributionUtils","category":"page"},{"location":"API/DistributionUtils/","page":"DistributionUtils","title":"DistributionUtils","text":"construct_priors\ndeserialize_prior\nflatten_config_dict\nflat_dict_keys_where\nlogmean_and_logstd\nmean_and_std_from_ln","category":"page"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.construct_priors","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.construct_priors","text":"construct_priors(\n    params::Dict{String, Vector{Constraint}};\n    unconstrained_σ::Float64 = 1.0,\n    prior_mean::Union{Vector{Float64}, Nothing} = nothing,\n    outdir_path::String = pwd(),\n    to_file::Bool = true,\n)\n\nDefine a prior Gaussian ParameterDistribution in unconstrained space from a dictionary of constraints.\n\nThis constructor assumes independent priors and the same unconstrained standard deviation for each parameter. Note that the standard deviation in unconstrained space is normalized with respect to the constrained interval width, so it automatically takes into account parameter scales.\n\nThe constructor also allows passing a prior mean for each parameter in constrained space.\n\nInputs:\n\nparams :: Dictionary of parameter names to constraints.\nunconstrained_σ :: Standard deviation of the transformed gaussians (unconstrained space).\nprior_mean :: The mean value of the prior in constrained space. If not given,  the prior is selected to be 0 in unconstrained space.\noutdir_path :: Output path.\nto_file :: Whether to write the serialized prior to a JLD2 file.\n\nOutput:\n\nThe prior ParameterDistribution.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.deserialize_prior","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.deserialize_prior","text":"deserialize_prior(prior_dict::Dict{String, Any})\n\nGenerates a prior ParameterDistribution from arguments stored in a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.flatten_config_dict","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.flatten_config_dict","text":"flatten_config_dict(param_dict::Dict{String, Vector{T}})\n\nGiven a dictionary of parameter names to parameter vectors of arbitrary length, return a new dictionary that maps a unique parameter name to each element of the full flattened vector of parameters.\n\nInputs:\n\nparam_dict :: Dictionary of parameter names to constraints.\n\nOutputs:\n\nu_names :: Vector{String} :: vector of parameter names\nvalues :: Vector{Vector{T}} :: vector of single-valued vectors encapsulating parameter values.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.flat_dict_keys_where","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.flat_dict_keys_where","text":"flat_dict_keys_where(dict::Dict{String, Vector{T}}, condition::Function = identity) where {T}\n\nFlattens the values of a dictionary with parameter vectors as keys, and returns the indices of entries in the flattened dictionary satisfying a given condition.\n\nInputs:     param_dict :: Dictionary of parameter names to vectors.     condition :: A condition function operating on each dictionary value. Outputs:     Indices of flattened entries satisfying the condition.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.logmean_and_logstd","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.logmean_and_logstd","text":"logmean_and_logstd(μ, σ)\n\nReturns the lognormal parameters μ and σ from the mean μ and std σ of the lognormal distribution.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.mean_and_std_from_ln","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.mean_and_std_from_ln","text":"mean_and_std_from_ln(μ, σ)\n\nReturns the mean and variance of the lognormal distribution from the lognormal parameters μ and σ.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"CurrentModule = CalibrateEDMF.Diagnostics","category":"page"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"This module defines and implements diagnostics of the training process. Diagnostics are organized into groups (defined as dictionaries io_dictionary_...) and written to file in netCDF4 format. All implemented dictionaries, as well as all their entries, are defined below. These include error metrics, parameter ensembles and their statistical moments, validation diagnostics, and more. ","category":"page"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"The diagnostics are meant to evolve organically as users require more information regarding the training process. If you can think of diagnostics that may be useful to a wide range of users, consider opening an issue or pull request on GitHub.","category":"page"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Data within the resulting Diagnostics.nc file can be analyzed using the Julia package NCDatasets.jl. The file can also be processed using software written in other popular programming languages like python through netCDF4-python or xarray.","category":"page"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"io_dictionary_metrics\nio_dictionary_val_metrics\nio_dictionary_ensemble\nio_dictionary_particle_state\nio_dictionary_particle_eval\nio_dictionary_val_particle_eval\nio_dictionary_reference\nio_dictionary_val_reference\nio_dictionary_prior\nget_ϕ_cov\nget_metric_var\nget_mean_nearest_neighbor\ncompute_ensemble_loss","category":"page"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_metrics","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_metrics","text":"io_dictionary_metrics()\nio_dictionary_metrics(ekp::EnsembleKalmanProcess, mse_full::Vector{FT}) where {FT <: Real}\n\nScalar metrics dictionary.\n\nEvaluations of the data-model mismatch in inverse problem (i.e., latent) space are denoted loss. Errors computed in normalized physical (i.e., full) space are denoted mse_full. Differences between these two metrics include:\n\nCovariance matrix defining the inner product (covariance weighting in loss vs L2 norm in mse_full),\nTreatment of trailing eigenvalues (truncation and regularization vs considering all eigenmodes).\nThe loss includes the L2 penalty term, mse_full does not.\n\nElements:\n\nloss_mean_g :: (ḡ - y)'Γ_inv(ḡ - y). This is the ensemble mean loss seen by the Kalman inversion process.\nloss_mean :: Ensemble mean of (g - y)'Γ_inv(g - y).\nloss_min :: Ensemble min of (g - y)'Γ_inv(g - y).\nloss_max :: Ensemble max of (g - y)'Γ_inv(g - y).\nloss_var :: Variance estimate of (g - y)'Γ_inv(g - y), empirical (EKI/EKS) or quadrature (UKI).\nloss_nn_mean :: (g_nn - y)'Γ_inv(nn - y), where g_nn is the forward model output at the particle closest to the mean in parameter space.\nmse_full_mean :: Ensemble mean of MSE(g_full, y_full).\nmse_full_min :: Ensemble min of MSE(g_full, y_full).\nmse_full_max :: Ensemble max of MSE(g_full, y_full).\nmse_full_var :: Variance estimate of MSE(g_full, y_full), empirical (EKI/EKS) or quadrature (UKI).\nmse_full_nn_mean :: MSE(g_full, y_full) of particle closest to the mean in parameter space. The mean in parameter space is the solution to the particle-based inversion.\nfailures :: Number of particle failures per iteration. If the calibration is run with the \"high_loss\" failure handler, this diagnostic will not capture the failures due to masking.\nnn_mean_index :: Particle index of the nearest neighbor to the ensemble mean in parameter space. This index is used to construct ..._nn_mean metrics.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_val_metrics","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_val_metrics","text":"io_dictionary_val_metrics()\nio_dictionary_val_metrics(ekp::EnsembleKalmanProcess, mse_full::Vector{FT}) where {FT <: Real}\n\nDictionary of scalar validation metrics.\n\nEvaluations of the data-model mismatch in inverse problem (i.e., latent) space are denoted loss. Errors computed in normalized physical (i.e., full) space are denoted mse_full. Differences between these two metrics include:\n\nCovariance matrix defining the inner product (covariance weighting in loss vs L2 norm in mse_full),\nTreatment of trailing eigenvalues (truncation and regularization vs considering all eigenmodes).\nThe loss includes the L2 penalty term, mse_full does not.\n\nElements:\n\nval_loss_mean :: Ensemble mean of validation (g - y)'Γ_inv(g - y).\nval_loss_min :: Ensemble min of validation (g - y)'Γ_inv(g - y).\nval_loss_max :: Ensemble max of validation (g - y)'Γ_inv(g - y).\nval_loss_var :: Variance estimate of validation (g - y)'Γ_inv(g - y), empirical (EKI/EKS) or quadrature (UKI).\nval_loss_nn_mean :: Validation (g_nn - y)'Γ_inv(nn - y), where g_nn is the validation forward model output at the particle closest to the mean in parameter space.\nval_mse_full_mean :: Ensemble mean of MSE(g_full_val, y_full_val).\nval_mse_full_min :: Ensemble min of MSE(g_full_val, y_full_val).\nval_mse_full_max :: Ensemble max of MSE(g_full_val, y_full_val).\nval_mse_full_var :: Variance estimate of MSE(g_full_val, y_full_val), empirical (EKI/EKS) or quadrature (UKI).\nval_mse_full_nn_mean :: MSE(g_full_val, y_full_val) of particle closest to the mean in parameter space. The mean in parameter space is the solution to the particle-based inversion.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_ensemble","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_ensemble","text":"io_dictionary_ensemble()\nio_dictionary_ensemble(ekp::EnsembleKalmanProcess, priors::ParameterDistribution)\n\nDictionary of ensemble parameter diagnostics.\n\nElements:\n\nu_mean :: Ensemble mean parameter in unconstrained (inverse problem) space.\nphi_mean :: Ensemble mean parameter in constrained (physical) space.\nu_cov :: Sample parameter covariance in unconstrained (inverse problem) space.\nphi_cov :: Sample parameter covariance in constrained (physical) space.\nphi_low_unc :: Lower uncertainty bound (μ-1σ) of the parameter value in constrained (physical) space.\nphi_upp_unc :: Upper uncertainty bound (μ+1σ) of the parameter value in constrained (physical) space.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_particle_state","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_particle_state","text":"io_dictionary_particle_state()\nio_dictionary_particle_state(ekp::EnsembleKalmanProcess, priors::ParameterDistribution)\n\nDictionary of particle-wise parameter diagnostics, not involving forward model evaluations.\n\nElements:\n\nu   :: Parameter ensemble in unconstrained (inverse problem) space.\nphi :: Parameter ensemble in constrained (physical) space.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_particle_eval","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_particle_eval","text":"io_dictionary_particle_eval()\nio_dictionary_particle_eval(\n    ekp::EnsembleKalmanProcess,\n    g_full::Matrix{FT},\n    mse_full::Vector{FT},\n    d::IT,\n    d_full::IT,\n    batch_indices::Vector{IT},\n) where {FT <: Real, IT <: Integer}\n\nDictionary of particle-wise diagnostics involving forward model evaluations.\n\nElements:\n\ng :: Forward model evaluation in inverse problem space.\ng_full :: Forward model evaluation in primitive output space, normalized using the pooled field covariance.\nmse_full :: Particle-wise evaluation of MSE(g_full, y_full).\nbatch_indices :: Indices of ReferenceModels evaluated per iteration.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_val_particle_eval","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_val_particle_eval","text":"io_dictionary_val_particle_eval()\nio_dictionary_val_particle_eval(\n    g::Matrix{FT},\n    g_full::Matrix{FT},\n    mse_full::Vector{FT},\n    d::IT,\n    d_full::IT,\n    batch_indices::Vector{IT},\n) where {FT <: Real, IT <: Integer}\n\nDictionary of particle-wise validation diagnostics involving forward model evaluations.\n\nElements:\n\nval_g :: Validation forward model evaluation in reduced space.\nval_g_full :: Validation forward model evaluation in primitive output space, normalized using the pooled field covariance.\nval_mse_full :: Particle-wise evaluation of MSE(val_g_full, val_y_full).\nval_batch_indices :: Indices of validation ReferenceModels evaluated per iteration.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_reference","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_reference","text":"io_dictionary_reference()\nio_dictionary_reference(\n    ref_stats::ReferenceStatistics,\n    ref_models::Vector{ReferenceModel},\n    write_full_stats::Bool = true,\n)\n\nDictionary of diagnostics pertaining to the ReferenceModels and ReferenceStatistics that define the inverse problem.\n\nElements:\n\nGamma :: Covariance matrix in the inverse problem latent space (regularized low-dimensional encoding).\nGamma_full :: Covariance matrix of normalized observed variables in full space (possibly ill-conditioned). Only written to file if write_full_stats is true.\nGamma_full_diag :: Diagonal of Gamma_full, useful when Gamma_full is not written to file.\ny :: Observations in the inverse problem latent space (low-dimensional encoding).\ny_full :: Normalized observations in full space.\nP_pca :: PCA projection matrix from full space to low-dimensional latent space.\nnum_vars :: Maximum number of observed fields (not dimensions) per ReferenceModel.\nvar_dof :: Maximum number of degrees of freedom of each field per ReferenceModel.\nconfig_pca_dim :: Dimensionality of the latent space associated with each ReferenceModel.\nconfig_name :: Name of each ReferenceModel used to construct the inverse problem.\nconfig_z_obs :: Vertical locations of the observations of each ReferenceModel.\nnorm_factor :: Pooled variance used to normalize each field of each ReferenceModel.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_val_reference","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_val_reference","text":"io_dictionary_val_reference()\nio_dictionary_val_reference(\n    ref_stats::ReferenceStatistics,\n    ref_models::Vector{ReferenceModel},\n    write_full_stats::Bool = true,\n)\n\nDictionary of diagnostics pertaining to the ReferenceModels and ReferenceStatistics in the validation set.\n\nElements:\n\nGamma_val :: Covariance matrix in latent space, using the same truncation as for the training set.\nGamma_full_val :: Covariance matrix of normalized observed variables in full space. Only written to file if write_full_stats is true.\nGamma_full_diag_val :: Diagonal of Gamma_full_val, useful when Gamma_full_val is not written to file.\ny_val :: Observations in latent space, for observed fields in the validation set.\ny_full_val :: Normalized observations in full space, for the validation set.\nP_pca_val :: PCA projection matrix from full space to low-dimensional latent space, for the validation set.\nnum_vars_val :: Maximum number of observed fields (not dimensions) per validation ReferenceModel.\nvar_dof_val :: Maximum number of degrees of freedom of each field per validation ReferenceModel.\nconfig_pca_dim_val :: Dimensionality of the latent space associated with each validation ReferenceModel.\nconfig_name_val :: Name of each ReferenceModel in the validation set.\nconfig_z_obs_val :: Vertical locations of the observations of each validation ReferenceModel.\nnorm_factor_val :: Pooled variance used to normalize each field of each validation ReferenceModel.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_prior","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_prior","text":"io_dictionary_prior()\nio_dictionary_prior(priors::ParameterDistribution)\n\nParameter prior diagnostics dictionary.\n\nElements:\n\nu_mean_prior :: Prior mean in unconstrained parameter space.\nphi_mean_prior :: Prior mean in constrained parameter space.\nu_var_prior :: Diagonal of the prior covariance in unconstrained space.\nphi_low_unc_prior :: Lower uncertainty bound (μ-1σ_prior) of prior in constrained space.\nphi_upp_unc_prior :: Upper uncertainty bound (μ+1σ_prior) of prior in constrained space.\nphi_low_std_prior :: Lower standard bound (μ-1) of prior in constrained space. Useful measure of minimum allowed values for bounded parameters.\nphi_upp_std_prior :: Upper standard bound (μ+1) of prior in constrained space. Useful measure of maximum allowed values for bounded parameters.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.get_ϕ_cov","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.get_ϕ_cov","text":"get_ϕ_cov(ekp::EnsembleKalmanProcess, priors::ParameterDistribution)\n\nGet the last parameter covariance estimate in constrained (physical) space.\n\nFor ensemble methods, the covariance of the transformed parameters is returned. For unscented methods, the covariance is computed through a quadrature on the transformed quadrature points. The covariance of the transformed parameters returned here is equal to the transformed covariance only under a first order Taylor approximation, which is consistent with other approximations underlying the calibration method.\n\nInputs:\n\nekp    :: The EnsembleKalmanProcess.\npriors :: The priors defining transformations between constrained and unconstrained space.\n\nOutputs:\n\nThe parameter covariance in constrained space.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.get_metric_var","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.get_metric_var","text":"get_metric_var(ekp::EnsembleKalmanProcess, metric::Vector{FT}) where {FT <: Real}\n\nComputes the ensemble variance of a scalar metric.\n\nFor ensemble methods, the sample variance of the metric is returned. For unscented methods, the variance is computed through a quadrature. Ensemble members where the metric is NaN are filtered out of the computation.\n\nInputs:\n\nekp    :: The EnsembleKalmanProcess.\nmetric :: A vector containing the value of the metric for each ensemble member.\n\nOutputs:\n\nThe ensemble variance of metric.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.get_mean_nearest_neighbor","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.get_mean_nearest_neighbor","text":"get_mean_nearest_neighbor(ekp::EnsembleKalmanProcess)\n\nReturns the index of the nearest neighbor to the ensemble mean parameter, in unconstrained space.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.compute_ensemble_loss","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.compute_ensemble_loss","text":"compute_ensemble_loss(\n    g::AbstractMatrix{FT},\n    y::AbstractVector{FT},\n    Γ::Union{AbstractMatrix{FT}, UniformScaling{FT}},\n) where {FT <: Real}\ncompute_ensemble_loss(ekp::EnsembleKalmanProcess)\n\nComputes the covariance-weighted error (g - y)'Γ_inv(g - y) for each ensemble member.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#HelperFuncs","page":"HelperFuncs","title":"HelperFuncs","text":"","category":"section"},{"location":"API/HelperFuncs/","page":"HelperFuncs","title":"HelperFuncs","text":"CurrentModule = CalibrateEDMF.HelperFuncs","category":"page"},{"location":"API/HelperFuncs/","page":"HelperFuncs","title":"HelperFuncs","text":"vertical_interpolation\nnc_fetch_interpolate\nfetch_interpolate_transform\nget_height\nget_dz\nnormalize_profile\nnc_fetch\nis_face_variable\nget_stats_path\ncompute_mse\npenalize_nan\nserialize_struct\ndeserialize_struct\njld2_path\nwrite_versions\nget_entry\nchange_entry!","category":"page"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.vertical_interpolation","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.vertical_interpolation","text":"vertical_interpolation(\n    var_name::String,\n    filename::String,\n    z_scm::Vector{FT};\n) where {FT <: AbstractFloat}\n\nReturns the netcdf variable varname interpolated to heights zscm.\n\nInputs:\n\nvar_name :: Name of variable in the netcdf dataset.\nfilename :: nc filename\nz_scm :: Vertical coordinate vector onto which var_name is interpolated.\n\nOutput:\n\nThe interpolated vector.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.nc_fetch_interpolate","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.nc_fetch_interpolate","text":"nc_fetch_interpolate(\n    var_name::String,\n    filename::String,\n    z_scm::Union{Vector{<:Real}, Nothing};\n)\n\nReturns the netcdf variable varname, possibly interpolated to heights zscm.\n\nInputs:\n\nvar_name :: Name of variable in the netcdf dataset.\nfilename :: nc filename\nz_scm :: Vertical coordinate vector onto which var_name is interpolated.\n\nOutput:\n\nThe interpolated vector.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.fetch_interpolate_transform","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.fetch_interpolate_transform","text":"fetch_interpolate_transform(\n    var_name::String,\n    filename::String,\n    z_scm::Union{Vector{<:Real}, Nothing};\n)\n\nReturns the netcdf variable varname, possibly interpolated to heights zscm. If the variable needs to be transformed to be equivalent to an SCM variable, applies the transformation as well.\n\nInputs:\n\nvar_name :: Name of variable in the netcdf dataset.\nfilename :: nc filename\nz_scm :: Vertical coordinate vector onto which var_name is interpolated.\n\nOutput:\n\nThe interpolated and transformed vector.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.get_height","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.get_height","text":"get_height(filename::String; get_faces::Bool = false)\n\nReturns the vertical cell centers or faces of the given configuration.\n\nInputs:\n\nfilename :: nc filename.\nget_faces :: If true, returns the coordinates of cell faces. Otherwise,  returns the coordinates of cell centers.\n\nOutput:\n\nz: Vertical level coordinates.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.normalize_profile","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.normalize_profile","text":"normalize_profile(profile_vec, n_vars, var_vec)\n\nPerform normalization of nvars profiles contained in profilevec using the variance associated with each variable, contained in var_vec.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.nc_fetch","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.nc_fetch","text":"nc_fetch(filename::String, var_names::NTuple{N, Tuple}) where {N}\nnc_fetch(filename::String, var_name::String)\n\nReturns the data for a variable var_name (or tuple of strings, varnames), looping through all dataset groups.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.is_face_variable","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.is_face_variable","text":"is_face_variable(filename::String, var_name::String)\n\nA Bool indicating whether the given variables is defined in faces, or not.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.get_stats_path","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.get_stats_path","text":"get_stats_path(dir)\n\nGiven directory to standard LES or SCM output, fetch path to stats file.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.compute_mse","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.compute_mse","text":"compute_mse(g_arr::Vector{Vector{FT}}, y::Vector{FT})::Vector{FT}\ncompute_mse(g_mat::Matrix{FT}, y::Vector{FT})::Vector{FT}\n\nComputes the L2-norm error of each vector, column or row of an array with respect to a vector y.\n\nOutput:\n\nThe mse for each ensemble member.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.penalize_nan","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.penalize_nan","text":"penalize_nan(arr::Vector{FT}; penalization::FT = 1.0e5) where {FT <: AbstractFloat}\n\nSubstitutes all NaN entries in arr by a penalization factor.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.serialize_struct","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.serialize_struct","text":"serialize_struct(s::T) where {T}\n\nSerializes the given structure as a dictionary to allow storage in JLD2 format.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.deserialize_struct","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.deserialize_struct","text":"deserialize_struct(dict::Dict{String}, ::Type{T})\n\nDeserializes the given dictionary and constructs a struct of the given type with the dictionary values.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.jld2_path","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.jld2_path","text":"jld2_path(root::String, identifier::Union{String, Int}, prefix::String)\n\nGenerates a JLD2 path, given a root path, an identifier and a prefix.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.write_versions","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.write_versions","text":"write_versions(versions::Vector{Int}, iteration::Int; outdir_path::String = pwd())\n\nWrites versions associated with an EnsembleKalmanProcess iteration to a text file.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.get_entry","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.get_entry","text":"get_entry(dict, key, default)\n\nCalls get but logs whether the default is used.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.change_entry!","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.change_entry!","text":"change_entry!(dict, keys_and_value)\n\nChanges the entry of a nested dictionary, giving a tuple of all its keys and the new value\n\nInputs:\n\ndict           :: Parent dictionary with an arbitrary number of nested dictionaries.\nkeys_and_value :: Tuple of keys from the parent dictionary to the entry to be modified,                   and the value to use to modify it.\n\n\n\n\n\n","category":"function"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"","category":"page"},{"location":"API/Pipeline/#Pipeline","page":"Pipeline","title":"Pipeline","text":"","category":"section"},{"location":"API/Pipeline/","page":"Pipeline","title":"Pipeline","text":"Module containing all high-level functions defining a training session workflow. User interactions should be done through the use of a config.jl file. See the experiments directory of the package for a few examples of config.jl files.","category":"page"},{"location":"API/Pipeline/","page":"Pipeline","title":"Pipeline","text":"CurrentModule = CalibrateEDMF.Pipeline","category":"page"},{"location":"API/Pipeline/","page":"Pipeline","title":"Pipeline","text":"init_calibration\nrestart_calibration\nek_update\nupdate_validation\nupdate_minibatch_inverse_problem\nwrite_model_evaluators\ninit_diagnostics\nupdate_diagnostics","category":"page"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.init_calibration","page":"Pipeline","title":"CalibrateEDMF.Pipeline.init_calibration","text":"init_calibration(job_id::String, config::Dict{Any, Any})\n\nInitializes a calibration process given a configuration, and a pipeline mode.\n\nInputs:\n\njob_id :: Unique job identifier for sbatch communication.\nconfig :: User-defined configuration dictionary.\nmode :: Whether the calibration process is parallelized through HPC resources or using Julia's pmap.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.restart_calibration","page":"Pipeline","title":"CalibrateEDMF.Pipeline.restart_calibration","text":"restart_calibration(\n    ekobj::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    last_iteration::Int64,\n    config::Dict{Any, Any},\n    outdir_path::String,\n)\n\nRestarts a calibration process from an EnsembleKalmanProcess, the parameter priors and the calibration process config file. If batching, it requires access to the last ReferenceModelBatch, stored in the results directory of the previous calibration, outdir_path.\n\nWrites to file the ModelEvaluators necessary to continue the calibration process.\n\nInputs:\n\nekobj          :: EnsembleKalmanProcess to be updated.\npriors         :: Priors over parameters, used for unconstrained-constrained mappings.\nlast_iteration :: Last iteration of the calibration process to be restarted.\nconfig         :: Configuration dictionary.\noutdir_path    :: Output path directory of the calibration process to be restarted.\nmode :: Whether the calibration process is parallelized through HPC resources or using Julia's pmap.\njob_id :: Unique job identifier for sbatch communication.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.ek_update","page":"Pipeline","title":"CalibrateEDMF.Pipeline.ek_update","text":"ek_update(\n    ekobj::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    iteration::Int64,\n    config::Dict{Any, Any},\n    versions::Vector{String},\n    outdir_path::String,\n)\n\nUpdates an EnsembleKalmanProcess using forward model evaluations stored in output files defined by their versions, and generates the parameters for the next ensemble for forward model evaluations. The updated EnsembleKalmanProcess and new ModelEvaluators are both written to file.\n\nInputs:\n\nekobj         :: EnsembleKalmanProcess to be updated.\npriors        :: Priors over parameters, used for unconstrained-constrained mappings.\niteration     :: Current iteration of the calibration process.\nconfig        :: Process configuration dictionary.\nversions      :: String versions identifying the forward model evaluations.\noutdir_path   :: Output path directory.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.update_validation","page":"Pipeline","title":"CalibrateEDMF.Pipeline.update_validation","text":"update_validation(\n    val_config::Dict{Any, Any},\n    reg_config::Dict{Any, Any},\n    ekp_old::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    versions::Vector{String},\n    outdir_path::String,\n    iteration::IT\n    )\n\nUpdates the validation diagnostics and writes to file the validation ModelEvaluators for the next calibration step.\n\nInputs:\n\nval_config    :: Validation model configuration.\nreg_config    :: Regularization configuration.\nekp_old       :: EnsembleKalmanProcess updated using the past forward model evaluations.\npriors        :: The priors over parameter space.\nversions      :: String versions identifying the forward model evaluations.\noutdir_path   :: Output path directory.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.update_minibatch_inverse_problem","page":"Pipeline","title":"CalibrateEDMF.Pipeline.update_minibatch_inverse_problem","text":"update_minibatch_inverse_problem(\n    rm_batch::ReferenceModelBatch,\n    ekp_old::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    batch_size::Integer,\n    outdir_path::String,\n    config::Dict{Any, Any},\n)\n\nReturns the EnsembleKalmanProcess and ReferenceStatistics consistent with the new ReferenceModel minibatch, and updates the evaluation order of the ReferenceModelBatch.\n\nInputs:\n\nrm_batch    :: The global ReferenceModelBatch with the current model evaluation order.\nekp_old     :: The EnsembleKalmanProcess from the previous minibatch evaluation.\nbatch_size  :: The batch size of the current minibatch.\noutdir_path :: The output directory.\nconfig      :: The configuration dictionary.\n\nOutputs:\n\nekp             :: The EnsembleKalmanProcess for the current minibatch.\nref_models      :: The current minibatch of ReferenceModels.\nref_stats       :: The ReferenceStatistics consistent with the current minibatch.\nrefmodelbatch :: The global ReferenceModelBatch with the updated model evaluation order.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.write_model_evaluators","page":"Pipeline","title":"CalibrateEDMF.Pipeline.write_model_evaluators","text":"write_model_evaluators(\n    ekp::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    ref_models::Vector{ReferenceModel},\n    ref_stats::ReferenceStatistics,\n    outdir_path::String,\n    iteration::Int,\n)\n\nCreates and writes to file the ModelEvaluators for the current particle ensemble.\n\nInputs:\n\nekp         :: The EnsembleKalmanProcess with the current ensemble of parameter values.\npriors      :: The parameter priors.\nref_models  :: The ReferenceModels defining the new model evaluations.\nref_stats   :: The ReferenceStatistics corresponding to passed ref_models.\noutdir_path :: The output directory.\niteration   :: The current process iteration.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.init_diagnostics","page":"Pipeline","title":"CalibrateEDMF.Pipeline.init_diagnostics","text":"init_diagnostics(\n    config::Dict{Any, Any},\n    outdir_path::String,\n    ref_stats::ReferenceStatistics,\n    ekp::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n)\n\nCreates a diagnostics netcdf file.\n\nInputs:\n\nconfig :: User-defined configuration dictionary.\noutdir_path :: Path of results directory.\nref_stats :: ReferenceStatistics.\nekp :: Initial EnsembleKalmanProcess, containing parameter information, but no forward model evaluations.\npriors:: Prior distributions of the parameters.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.update_diagnostics","page":"Pipeline","title":"CalibrateEDMF.Pipeline.update_diagnostics","text":"update_diagnostics(outdir_path::String, ekp::EnsembleKalmanProcess, priors::ParameterDistribution)\n\nAppends diagnostics of the current iteration evaluations (i.e., forward model output metrics) and the next iteration state (i.e., parameters and parameter metrics) to a diagnostics netcdf file.\n\nInputs:\n\noutdir_path :: Path of results directory.\nekp :: Current EnsembleKalmanProcess.\npriors:: Prior distributions of the parameters.\nref_stats :: ReferenceStatistics.\ng_full :: The forward model evaluation in primitive space.\nversions :: Version identifiers of the forward model evaluations at the current iteration.\nval_config :: The validation configuration, if given.\nbatch_indices :: The indices of the ReferenceModels used in the current batch.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#KalmanProcessUtils","page":"KalmanProcessUtils","title":"KalmanProcessUtils","text":"","category":"section"},{"location":"API/KalmanProcessUtils/","page":"KalmanProcessUtils","title":"KalmanProcessUtils","text":"CurrentModule = CalibrateEDMF.KalmanProcessUtils","category":"page"},{"location":"API/KalmanProcessUtils/","page":"KalmanProcessUtils","title":"KalmanProcessUtils","text":"PiecewiseConstantDecay\nPiecewiseConstantGrowth\nget_Δt\ngenerate_ekp\ngenerate_tekp\nget_sparse_indices\nget_regularized_indices","category":"page"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.PiecewiseConstantDecay","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.PiecewiseConstantDecay","text":"PiecewiseConstantDecay{FT <: Real, IT <: Int} <: LearningRateScheduler\n\nPiecewise constant decay learning rate scheduler.\n\nHalves the time step periodically with period τ.\n\nFields\n\nΔt_init::Real\nInitial learning rate\nτ::Int64\nHalving time\n\nConstructors\n\nPiecewiseConstantDecay(Δt_init, τ)\n\ndefined at /home/runner/work/CalibrateEDMF.jl/CalibrateEDMF.jl/src/KalmanProcessUtils.jl:47.\n\n\n\n\n\n","category":"type"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.PiecewiseConstantGrowth","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.PiecewiseConstantGrowth","text":"PiecewiseConstantGrowth{FT <: Real, IT <: Int} <: LearningRateScheduler\n\nPiecewise constant growth learning rate scheduler.\n\nDoubles the time step periodically with period τ.\n\nFields\n\nΔt_init::Real\nInitial learning rate\nτ::Int64\nDoubling time\n\nConstructors\n\nPiecewiseConstantGrowth(Δt_init, τ)\n\ndefined at /home/runner/work/CalibrateEDMF.jl/CalibrateEDMF.jl/src/KalmanProcessUtils.jl:69.\n\n\n\n\n\n","category":"type"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.get_Δt","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.get_Δt","text":"Retrieve learning rate Δt from a LearningRateScheduler\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.generate_ekp","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.generate_ekp","text":"generate_ekp(\n    ref_stats::ReferenceStatistics,\n    process::Process,\n    u::Union{Matrix{T}, T} = nothing;\n    failure_handler::String = \"ignore_failures\",\n    outdir_path::String = pwd(),\n    to_file::Bool = true,\n) where {T}\n\nGenerates, and possible writes to file, an EnsembleKalmanProcess from a parameter ensemble and reference statistics.\n\nInputs:\n\nref_stats :: ReferenceStatistics defining the inverse problem.\nprocess :: Type of EnsembleKalmanProcess used to evolve the ensemble.\nu :: An ensemble of parameter vectors, used if !isa(process, Unscented).\nfailure_handler :: String describing what failure handler to use.\noutdir_path :: Output path.\nto_file :: Whether to write the serialized prior to a JLD2 file.\n\nOutput:\n\nThe generated EnsembleKalmanProcess.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.generate_tekp","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.generate_tekp","text":"generate_tekp(\n    ref_stats::ReferenceStatistics,\n    priors::ParameterDistribution,\n    process::Process,\n    u::Union{Matrix{T}, T} = nothing;\n    l2_reg::Union{Dict{String, Vector{R}}, R} = nothing,\n    failure_handler::String = \"ignore_failures\",\n    outdir_path::String = pwd(),\n    to_file::Bool = true,\n) where {T, R}\n\nGenerates, and possible writes to file, a Tikhonov EnsembleKalmanProcess from a parameter ensemble and reference statistics.\n\nTikhonov regularization is implemented through output state augmentation with the input parameter vector. The input L2 regularization hyperparameter should be interpreted as the inverse of the variance of our prior belief in the magnitude of the parameters.\n\nInputs:\n\nref_stats :: ReferenceStatistics defining the inverse problem.\npriors :: Parameter priors used for L2 (i.e., Tikhonov) regularization\nprocess :: Type of EnsembleKalmanProcess used to evolve the ensemble.\nu :: An ensemble of parameter vectors, used if !isa(process, Unscented).\nl2_reg :: L2 regularization hyperparameter driving parameter values toward prior.      May be a float (isotropic regularization) or a dictionary of regularizations      per parameter.\nfailure_handler :: String describing what failure handler to use.\noutdir_path :: Output path.\nto_file :: Whether to write the serialized prior to a JLD2 file.\n\nOutput:\n\nThe generated augmented EnsembleKalmanProcess.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.get_sparse_indices","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.get_sparse_indices","text":"Returns the sparse parameter indices given the sparsity configuration and the number of parameters.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.get_regularized_indices","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.get_regularized_indices","text":"Returns the indices of parameters to be regularized, given the l2 regularization configuration dictionary.\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The main purpose of CalibrateEDMF.jl is to provide a user-friendly way to calibrate atmospheric turbulence and convection parameterizations within TurbulenceConvection.jl using gradient-free ensemble Kalman methods.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"All user directives are specified through a config.jl file. config.jl is a Julia-readable collection of nested dictionaries that define all aspects of the calibration process, including:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The data used for training and online validation,\nInverse problem and optimization regularization,\nThe algorithm used for calibration (Ensemble Kalman Inversion, Unscented Kalman Inversion, ...) and its hyperparameters,\nParameter bounds and prior distributions.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Several config.jl example files are included in the experiments/ directory of the package. The Pipeline.jl module implements the high-level functions called during a training session, from config-parsing to diagnostic output directives.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"CalibrateEDMF.jl implements several calibration pipelines, designed to exploit available parallelisms of the computing station at the user's disposal.","category":"page"},{"location":"getting_started/#Julia's-pmap()-pipeline","page":"Getting started","title":"Julia's pmap() pipeline","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"For personal computers, parallelism is implemented through Julia's pmap() function.","category":"page"},{"location":"getting_started/#How-to-run-(pmap()-pipeline)","page":"Getting started","title":"How to run (pmap() pipeline)","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Navigate to experiments/scm_pycles_pipeline/julia_parallel directory. The script calibrate.jl implements the workflow of a training session that leverages Julia's pmap() to perform parallel TurbulenceConvection.jl evaluations within each training step. Evaluations are parallelized across ensemble members. ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you are on the Caltech Central Cluster, you can run this pipeline by adding it to the SLURM schedule:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"sbatch calibrate_script ../config.jl","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Otherwise run locally, e.g.:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"sh calibrate_script ../config.jl","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Two parallelized pipelines are able to ingest the config.jl file and perform the calibration, one using Julia's pmap() and another one using parallel bash calls through a SLURM HPC manager. Parallelization is performed over ensemble members. If the ensemble members have to perform several evaluations of TurbulenceConvection.jl, these are performed serially. A fully parallel implementation (global_parallel) that parallelizes across all TurbulenceConvection.jl is included in experiments/SCT1_benchmark.","category":"page"},{"location":"getting_started/#SLURM-HPC-pipeline","page":"Getting started","title":"SLURM HPC pipeline","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"For users with access to a high-performance computing (HPC) cluster, the hpc_parallel may be more efficient. The HPC pipeline parallelizes jobs using different Julia sessions per ensemble member and iteration. Due to the just-in-time compilation nature of Julia, this would normally require compiling the source code again for every new HPC node requested. In order to reduce the compilation overhead, this pipeline builds a system image of EnsembleKalmanProcesses.jl, TurbulenceConvection.jl, CalibrateEDMF.jl and all the functions called in the CalibrateEDMF.jl unit test suite. This system image uses a frozen version of the source code, so it must be re-generated every time any of the precompiled packages is updated or modified by the user.","category":"page"},{"location":"getting_started/#How-to-run-(HPC-pipeline)","page":"Getting started","title":"How to run (HPC pipeline)","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Navigate to experiments/scm_pycles_pipeline/hpc_parallel directory. The master bash script that starts the calibration process is ekp_calibration.sbatch, which takes as an argument the path to the config file.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you are on the Caltech Central Cluster, you can run the project by adding it to the schedule:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"sbatch ekp_calibration.sbatch ../config.jl","category":"page"},{"location":"getting_started/#Output-of-the-training-pipeline","page":"Getting started","title":"Output of the training pipeline","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"While the simulations run, the results are dumped to a directory named results_... after every iteration of the calibration algorithm. Output of interest is stored in netCDF format, in Diagnostics.nc. To learn more about the diagnostics suite, see the Diagnostics.jl module.","category":"page"},{"location":"API/LESUtils/#LESUtils","page":"LESUtils","title":"LESUtils","text":"","category":"section"},{"location":"API/LESUtils/","page":"LESUtils","title":"LESUtils","text":"CurrentModule = CalibrateEDMF.LESUtils","category":"page"},{"location":"API/LESUtils/","page":"LESUtils","title":"LESUtils","text":"get_les_names\nfind_alias\nget_cfsite_les_dir\nget_LES_library","category":"page"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.get_les_names","page":"LESUtils","title":"CalibrateEDMF.LESUtils.get_les_names","text":"get_les_names(y_names::Vector{String}, filename::String)\nget_les_names(m::ReferenceModel, filename::String)\n\nReturns the aliases of the variables actually present in the nc file (filename) corresponding to SCM variables y_names.\n\n\n\n\n\n","category":"function"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.find_alias","page":"LESUtils","title":"CalibrateEDMF.LESUtils.find_alias","text":"find_alias(aliases::Tuple{Vararg{String}}, filename::String)\n\nFinds the alias present in an NCDataset from a list of possible aliases.\n\n\n\n\n\n","category":"function"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.get_cfsite_les_dir","page":"LESUtils","title":"CalibrateEDMF.LESUtils.get_cfsite_les_dir","text":"get_cfsite_les_dir(\n    cfsite_number::Integer;\n    forcing_model::String = \"HadGEM2-A\",\n    month::Integer = 7,\n    experiment::String = \"amip\",)\n\nGiven information about an LES run from Zhaoyi Shen, Akshay Sridhar, Zhihong Tan, Anna Jaruga, Tapio Schneider (2022), fetch LES directory on central cluster.\n\nInputs:\n\ncfsite_number  :: cfsite number\nforcing_model :: {\"HadGEM2-A\", \"CNRM-CM5\", \"CNRM-CM6-1\", \"IPSL-CM6A-LR\"} - name of climate model used for forcing. Currently, only \"HadGEM2-A\" simulations are available reliably.\nmonth :: {1, 4, 7, 10} - month of simulation.\nexperiment :: {\"amip\", \"amip4K\"} - experiment from which LES was forced.\n\nOutputs:\n\nles_dir - path to les simulation containing stats folder\n\n\n\n\n\n","category":"function"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.get_LES_library","page":"LESUtils","title":"CalibrateEDMF.LESUtils.get_LES_library","text":"get_LES_library\n\nHierarchical dictionary of available LES simulations described in Zhaoyi Shen, Akshay Sridhar, Zhihong Tan, Anna Jaruga, Tapio Schneider (2022). The following cfsites are available across listed models, months, and experiments.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#ReferenceModels","page":"ReferenceModels","title":"ReferenceModels","text":"","category":"section"},{"location":"API/ReferenceModels/","page":"ReferenceModels","title":"ReferenceModels","text":"CurrentModule = CalibrateEDMF.ReferenceModels","category":"page"},{"location":"API/ReferenceModels/","page":"ReferenceModels","title":"ReferenceModels","text":"ReferenceModel\nconstruct_reference_models\ntime_shift_reference_model\nget_z_obs\nget_scm_namelist\nReferenceModelBatch\nget_minibatch!\nreshuffle_on_epoch_end","category":"page"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.ReferenceModel","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.ReferenceModel","text":"ReferenceModel{FT <: Real}\n\nA structure containing information about the 'true' reference model and the observation map used to compare the parameterized and reference models.\n\nFields\n\ny_names::Vector{String}\nVector of reference variable names\ny_dir::String\nDirectory for reference data to compute y mean vector\nΣ_dir::String\nDirectory for reference data to compute Σ covariance matrix\nscm_dir::String\nDirectory for static data related to forward scm model (parameter file & vertical levels)\ncase_name::String\nName of case\ny_t_start::Real\nStart time for computing mean statistics over\ny_t_end::Real\nEnd time for computing mean statistics over\nΣ_t_start::Real\nStart time for computing covariance statistics over\nΣ_t_end::Real\nEnd time for computing covariance statistics over\nz_obs::Vector{FT} where FT<:Real\nVector of observed vertical locations\nnamelist::Dict\nTurbulenceConvection namelist\n\nConstructors\n\nReferenceModel(\n    y_names::Vector{String},\n    y_dir::String,\n    scm_dir::String,\n    case_name::String,\n    t_start::Real,\n    t_end::Real;\n    Σ_dir::Union{String, Nothing} = nothing,\n    Σ_t_start::Union{Real, Nothing} = nothing,\n    Σ_t_end::Union{Real, Nothing} = nothing,\n    n_obs::Union{Integer, Nothing} = nothing,\n    namelist_args = nothing,\n)\n\nReferenceModel constructor allowing for any or all of Σ_dir, Σ_t_start, Σ_t_end to be unspecified, in which case they take their values from y_dir, t_start and t_end, respectively.\n\nReferenceModel(\n    y_names::Vector{String},\n    y_dir::String,\n    scm_parent_dir::String,\n    scm_suffix::String,\n    case_name::String,\n    t_start::Real,\n    t_end::Real;\n    Σ_dir::Union{String, Nothing} = nothing,\n    Σ_t_start::Union{Real, Nothing} = nothing,\n    Σ_t_end::Union{Real, Nothing} = nothing,\n    n_obs::Union{Integer, Nothing} = nothing,\n    namelist_args = nothing,\n)\n\nReferenceModel constructor using scm_parent_dir, case_name, scm_suffix, to define scm_dir.\n\n\n\n\n\n","category":"type"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.construct_reference_models","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.construct_reference_models","text":"construct_reference_models(kwarg_ld::Dict{Symbol, Vector{T} where T})::Vector{ReferenceModel}\n\nReturns a vector of ReferenceModels given a dictionary of keyword argument lists.\n\nInputs:\n\nkwarg_ld     :: Dictionary of keyword argument lists\n\nOutputs:\n\nref_models   :: Vector where the i-th ReferenceModel is constructed from the i-th element of every keyword argument list of the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.time_shift_reference_model","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.time_shift_reference_model","text":"time_shift_reference_model(m::ReferenceModel, Δt::FT) where {FT <: Real}\n\nReturns a time-shifted ReferenceModel, considering an interval relative to the last available time step of the original model.\n\nInputs:\n\nm     :: A ReferenceModel.\nΔt  :: [LES last time - SCM start time (LES timeframe)]\n\nOutputs:\n\nThe time-shifted ReferenceModel.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.get_z_obs","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.get_z_obs","text":"Returns the observed vertical locations for a reference model\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.get_scm_namelist","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.get_scm_namelist","text":"get_scm_namelist(\n    output_dir::String,\n    case_name::String;\n    y_dir::Union{String, Nothing} = nothing,\n    overwrite::Bool = false,\n    namelist_args = nothing,\n)::Dict\n\nReturns a TurbulenceConvection.jl namelist, given the case and a list of namelist arguments.\n\nInputs:\n\noutput_dir     :: Directory where the namelist will be stored or should be located.\ncase_name      :: Name of the TurbulenceConvection.jl case considered.\ny_dir          :: Directory with LES data to drive the SCM with, if case_name is LES_driven_SCM.\noverwrite      :: Whether to overwrite the namelist file, if it exists.\nnamelist_args  :: Vector of non-default arguments to be used in the namelist, defined as a vector of tuples.\n\nOutputs:\n\nnamelist   :: The TurbulenceConvection.jl namelist.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.ReferenceModelBatch","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.ReferenceModelBatch","text":"struct ReferenceModelBatch\n\nA structure containing a batch of ReferenceModels and an evaluation order for ReferenceModels within the current epoch.\n\nFields\n\nref_models::Vector{CalibrateEDMF.ReferenceModels.ReferenceModel}\nVector containing all reference models\neval_order::Vector{Int64}\nVector of indices defining the ReferenceModel evaluation order when batching\n\nConstructors\n\nReferenceModelBatch(ref_models::Vector{ReferenceModel}, shuffling::Bool = true)\n\nReferenceModelBatch constructor given a vector of ReferenceModels.\n\nReferenceModelBatch(kwarg_ld::Dict{Symbol, Vector{T} where T}, shuffling::Bool = true)\n\nReferenceModelBatch constructor given a dictionary of keyword argument lists.\n\nInputs:\n\nkwarg_ld     :: Dictionary of keyword argument lists\nshuffling    :: Whether to shuffle the order of ReferenceModels.\n\n\n\n\n\n","category":"type"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.get_minibatch!","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.get_minibatch!","text":"get_minibatch!(ref_models::ReferenceModelBatch, batch_size::Int)\n\nReturns a minibatch of ReferenceModels from a ReferenceModelBatch and updates the eval order.\n\nThe size of the minibatch is either the requested size, or the remainder of the elements in the eval_order for this epoch.\n\nInputs:\n\nref_model_batch :: A ReferenceModelBatch.\nbatch_size      :: The number of ReferenceModels to retrieve.\n\nOutputs:\n\nA vector of ReferenceModels.\nThe indices of the returned ReferenceModels.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.reshuffle_on_epoch_end","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.reshuffle_on_epoch_end","text":"Restarts a shuffled evaluation order if the current epoch has finished.\n\n\n\n\n\n","category":"function"},{"location":"#CalibrateEDMF.jl","page":"Home","title":"CalibrateEDMF.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CalibrateEDMF","category":"page"},{"location":"","page":"Home","title":"Home","text":"CalibrateEDMF is a julia package that enables the calibration of atmospheric turbulence and convection parameterizations using gradient-free ensemble Kalman methods. It provides a user-friendly framework to train parameterizations implemented in TurbulenceConvection.jl, using the ensemble-based optimization methods implemented in EnsembleKalmanProcesses.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some of the options enabled by the package are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Automatic regularization of parameter learning as an inverse problem,\nMinibatch training using EnsembleKalmanProcesses.jl,\nKalman inversion with isotropic or anisotropic regularization,\nTracking of validation diagnostics, given a user-specified validation dataset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The rationale behind the calibration framework implemented in this package is thoroughly described in our preprint:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lopez-Gomez, I., Christopoulos, C., Langeland Ervik, H. L., Dunbar, O. R. A., Cohen, Y., Schneider, T. (2022) Training physics-based machine-learning parameterizations with gradient-free ensemble Kalman methods. preprint","category":"page"},{"location":"","page":"Home","title":"Home","text":"The manuscript also includes results for an extended eddy-diffusivity mass-flux (EDMF) closure of turbulence and convection trained using this package. If you use this package for your own research, or find any of the ideas presented useful, please cite our work.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CalibrateEDMF.jl is being developed by the Climate Modeling Alliance. The main developers are Ignacio Lopez-Gomez (lead), Haakon Ludvig Langeland Ervik, Charles Kawczynski, Costa Christopoulos and Yair Cohen.","category":"page"}]
}
