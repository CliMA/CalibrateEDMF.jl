var documenterSearchIndex = {"docs":
[{"location":"tc_runner/#Diagnostics-Tools","page":"Running TC.jl with optimal parameters","title":"Diagnostics Tools","text":"","category":"section"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"A general set of tools for analyzing CalibrateEDMF.jl output and running TurbulenceConvection.jl with optimal parameters.","category":"page"},{"location":"tc_runner/#TCRunner.jl","page":"Running TC.jl with optimal parameters","title":"TCRunner.jl","text":"","category":"section"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"A command line script for running TurbulenceConvection.jl with a set of optimal parameters determined from CalibrateEDMF.jl on various datasets (--run_set). Runs validation cases from CEDMF config in --results_dir with optimal parameters by default. Ideally, calibration hyperparmeters and variations of the EDMF model are chosen using results on the validation set and offline performance is evaluated on the test set. Available run_sets:","category":"page"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"run_set Description\nreference Run TC with optimal parameters on all cases in the training set (reference in the calibration config.)\nvalidation Run TC with optimal parameters on all cases in the validation set (validation in the calibration config.)\ntest Run TC with optimal parameters on all cases in a newly-defined test set, (cases defined in get_reference_config(::ScmTest) in the config file defined at --run_set_config). See tools/test_set_config.jl for an example.","category":"page"},{"location":"tc_runner/#Usage","page":"Running TC.jl with optimal parameters","title":"Usage","text":"","category":"section"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"julia --project TCRunner.jl --results_dir=<CEDMF OUTPUT DIR> --tc_output_dir=<DIR TO STORE TC OUTPUTS>","category":"page"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"or use optional arguments for determining optimal parameters. For example, to run TC using parameters of the particle with lowest mse on the validation set:","category":"page"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"julia --project TCRunner.jl --results_dir=<CEDMF OUTPUT DIR> --tc_output_dir=<DIR TO STORE TC OUTPUTS> --method=\"best_particle\" --metric=\"val_mse_full\"","category":"page"},{"location":"tc_runner/#DiagnosticsTools.jl","page":"Running TC.jl with optimal parameters","title":"DiagnosticsTools.jl","text":"","category":"section"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"Utility functions to determine optimal parameters and mse values from completed calibration runs.","category":"page"},{"location":"tc_runner/#Usage-2","page":"Running TC.jl with optimal parameters","title":"Usage","text":"","category":"section"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"u_names, u = optimal_parameters(<PATH TO \"Diagnostics.nc\">; method = \"best_nn_particle_mean\", metric = \"mse_full\")","category":"page"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"Given path to Diagnostics.nc file, return optimal parameter set across all iterations and corresponding parameter names. Defaults to particle nearest to ensemble mean (nearest neighbor) for the iteration with minimal mean mse on the training set. See docstring or table below for more options.","category":"page"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"optimal_mse_train, optimal_mse_val = optimal_mse(<PATH TO \"Diagnostics.nc\">; method = \"best_nn_particle_mean\", metric = \"mse_full\")","category":"page"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"Given path to Diagnostics.nc file, return minimum mse across iterations. Use in concert with optimal_parameters to find the mse associated with a set of optimal parameters. Defaults to returning training and validation mse of particle nearest to ensemble mean for the iteration with minimal mse on the training set.","category":"page"},{"location":"tc_runner/#Optimal-Parameter-Methods","page":"Running TC.jl with optimal parameters","title":"Optimal Parameter Methods","text":"","category":"section"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"method Description\nbest_nn_particle_mean Returns parameters for particle nearest to ensemble mean for the iteration with lowest mean training (metric = \"mse_full\") or validation (metric = \"val_mse_full\") mse.\nbest_particle Returns parameters for particle with lowest mse on training (metric = \"mse_full\") or validation (metric = \"val_mse_full\") set.","category":"page"},{"location":"tc_runner/#Optimal-Parameter-Metrics","page":"Running TC.jl with optimal parameters","title":"Optimal Parameter Metrics","text":"","category":"section"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"metric Description\nmse_full Find minimal mse of training set or mini-batch subset (reference in the calibration config.)\nval_mse_full Find minimal mse of validation set or mini-batch subset (validation in the calibration config.)","category":"page"},{"location":"tc_runner/","page":"Running TC.jl with optimal parameters","title":"Running TC.jl with optimal parameters","text":"Note that using mini-batching will result in an mse computed on a subset of the full training or validation dataset, so it is advantageous to evaluate (metric = \"val_mse_full\") on a validation set without batching if batching is used for the training set. ","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Thank you for considering contributing to CalibrateEDMF! We encourage opening issues and pull requests (PRs).","category":"page"},{"location":"contributing/#What-to-contribute?","page":"Contributing","title":"What to contribute?","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The easiest way to contribute is by using CalibrateEDMF, identifying problems and opening issues;\nYou can try to tackle an existing issue. It is best to outline your proposed solution in the issue thread before implementing it in a PR;\nWrite an example or tutorial. It is likely that other users may find your use of CalibrateEDMF insightful;\nImprove documentation or comments if you found something hard to use;\nImplement a new feature if you need it. We strongly encourage opening an issue to make sure the administrators are on board before opening a PR with an unsolicited feature addition.","category":"page"},{"location":"contributing/#Using-git","page":"Contributing","title":"Using git","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you are unfamiliar with git and version control, the following guides will be helpful:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Atlassian (bitbucket) git tutorials. A set of tips and tricks for getting started with git.\nGitHub's git tutorials. A set of resources from GitHub to learn git.","category":"page"},{"location":"contributing/#Forks-and-branches","page":"Contributing","title":"Forks and branches","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Create your own fork of CalibrateEDMF on GitHub and check out your copy:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git clone https://github.com/<your-username>/CalibrateEDMF.jl.git\n$ cd CalibrateEDMF.jl","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Now you have access to your fork of CalibrateEDMF through origin. Create a branch for your feature; this will hold your contribution:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git checkout -b <branchname>","category":"page"},{"location":"contributing/#Some-useful-tips","page":"Contributing","title":"Some useful tips","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"When you start working on a new feature branch, make sure you start from main by running: git checkout main and git pull.\nCreate a new branch from main by using git checkout -b <branchname>.","category":"page"},{"location":"contributing/#Develop-your-feature","page":"Contributing","title":"Develop your feature","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Make sure you add tests for your code in test/ and appropriate documentation in the code and/or in docs/. Before committing your changes, you can verify their behavior by running the tests, the examples, and building the documentation locally. In addition, make sure your feature follows the formatting guidelines by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"julia --project=.dev .dev/climaformat.jl .","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"from the CalibrateEDMF.jl directory.","category":"page"},{"location":"contributing/#Squash-and-rebase","page":"Contributing","title":"Squash and rebase","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"When your PR is ready for review, clean up your commit history by squashing and make sure your code is current with CalibrateEDMF.jl main by rebasing. The general rule is that a PR should contain a single commit with a descriptive message.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To make sure you are up to date with main, you can use the following workflow:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git checkout main\n$ git pull\n$ git checkout <name_of_local_branch>\n$ git rebase main","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This may create conflicts with the local branch. The conflicted files will be outlined by git. To resolve conflicts, we have to manually edit the files (e.g. with vim). The conflicts will appear between >>>>, ===== and <<<<<. We need to delete these lines and pick what version we want to keep.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To squash your commits, you can use the following command:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git rebase -i HEAD~n","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"where n is the number of commits you need to squash into one. Then, follow the instructions in the terminal. For example, to squash 4 commits:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git rebase -i HEAD~4","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"will open the following file in (typically) vim:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"   pick 01d1124 <commit message 1>\n   pick 6340aaa <commit message 2>\n   pick ebfd367 <commit message 3>\n   pick 30e0ccb <commit message 4>\n\n   # Rebase 60709da..30e0ccb onto 60709da\n   #\n   # Commands:\n   #  p, pick = use commit\n   #  e, edit = use commit, but stop for amending\n   #  s, squash = use commit, but meld into previous commit\n   #\n   # If you remove a line here THAT COMMIT WILL BE LOST.\n   # However, if you remove everything, the rebase will be aborted.\n##","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We want to keep the first commit and squash the last 3. We do so by changing the last three commits to squash and then do :wq on vim.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"   pick 01d1124 <commit message 1>\n   squash 6340aaa <commit message 2>\n   squash ebfd367 <commit message 3>\n   squash 30e0ccb <commit message 4>\n\n   # Rebase 60709da..30e0ccb onto 60709da\n   #\n   # Commands:\n   #  p, pick = use commit\n   #  e, edit = use commit, but stop for amending\n   #  s, squash = use commit, but meld into previous commit\n   #\n   # If you remove a line here THAT COMMIT WILL BE LOST.\n   # However, if you remove everything, the rebase will be aborted.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Then in the next screen that appears, we can just delete all messages that we do not want to show in the commit. After this is done and we are back to  the console, we have to force push. We need to force push because we rewrote the local commit history.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ git push -u origin <name_of_local_branch> --force","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"You can find more information about squashing here.","category":"page"},{"location":"contributing/#Unit-testing","page":"Contributing","title":"Unit testing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Currently a number of checks are run per commit for a given PR.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"JuliaFormatter checks if the PR is formatted with .dev/climaformat.jl.\nDocumentation rebuilds the documentation for the PR and checks if the docs are consistent and generate valid output.\nUnit Tests run subsets of the unit tests defined in tests/, using Pkg.test(). The tests are run in parallel to ensure that they finish in a reasonable time. The tests only run the latest commit for a PR, branch and will kill any stale jobs on push. These tests are only run on linux (Ubuntu LTS).","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Unit tests are run against every new commit for a given PR, the status of the unit-tests are not checked during the merge process but act as a sanity check for developers and reviewers. Depending on the content changed in the PR, some CI checks that are not necessary will be skipped.  For example doc only changes do not require the unit tests to be run.","category":"page"},{"location":"contributing/#The-merge-process","page":"Contributing","title":"The merge process","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We use bors to manage merging PR's in the the CalibrateEDMF repo. If you're a collaborator and have the necessary permissions, you can type bors try in a comment on a PR to have integration test suite run on that PR, or bors r+ to try and merge the code.  Bors ensures that all integration tests for a given PR always pass before merging into main. The integration tests currently run example cases in examples/. Any breaking changes will need to also update the examples/, else bors will fail.","category":"page"},{"location":"API/ReferenceStats/#ReferenceStats","page":"ReferenceStats","title":"ReferenceStats","text":"","category":"section"},{"location":"API/ReferenceStats/","page":"ReferenceStats","title":"ReferenceStats","text":"CurrentModule = CalibrateEDMF.ReferenceStats","category":"page"},{"location":"API/ReferenceStats/","page":"ReferenceStats","title":"ReferenceStats","text":"ReferenceStatistics\nget_obs\nobs_PCA\npca\npca_length\nfull_length\nget_profile\nget_time_covariance","category":"page"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.ReferenceStatistics","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.ReferenceStatistics","text":"ReferenceStatistics{FT <: Real, IT <: Integer}\n\nA structure containing statistics from the reference model used to define a well-posed inverse problem.\n\nFields\n\ny::Vector{FT} where FT<:Real\nReference data, length: nSim * nvars * nzLevels (possibly reduced by PCA)\nΓ::AbstractMatrix{FT} where FT<:Real\nData covariance matrix, dims: (y,y) (possibly reduced by PCA)\nnorm_vec::Array{Vector{FT}, 1} where FT<:Real\nVector (length: nSim) of normalizing factors (length: n_vars)\npca_vec::Array{Union{LinearAlgebra.UniformScaling, AbstractMatrix{FT}}, 1} where FT<:Real\nVector (length: nSim) of PCA projection matrices with leading eigenvectors as columns\ny_full::Vector{FT} where FT<:Real\nFull reference data vector, length: nSim * n_vars * n_zLevels\nΓ_full::SparseArrays.SparseMatrixCSC{FT, Int64} where FT<:Real\nFull covariance matrix, dims: (y,y)\nndof_case::Vector{IT} where IT<:Integer\nDegrees of freedom per case (possibly reduced by PCA)\nndof_full_case::Vector{IT} where IT<:Integer\nFull degrees of freedom per case: zdof * n_vars\nzdof::Vector{IT} where IT<:Integer\nVertical degrees of freedom in profiles per case\n\nConstructors\n\nReferenceStatistics(\n    RM::Vector{ReferenceModel};\n    perform_PCA::Bool = true,\n    normalize::Bool = true,\n    variance_loss::FT = 0.1,\n    tikhonov_noise::FT = 0.0,\n    tikhonov_mode::String = \"absolute\",\n    dim_scaling::Bool = false,\n    y_type::ModelType = LES(),\n    Σ_type::ModelType = LES(),\n    Δt::FT = 6 * 3600.0,\n    model_errors::OptVec{T} = nothing,\n) where {FT <: Real}\n\nConstructs the ReferenceStatistics defining the inverse problem.\n\nInputs:\n\nRM               :: Vector of ReferenceModels.\nperform_PCA      :: Boolean specifying whether to perform PCA.\nnormalize        :: Boolean specifying whether to normalize the data.\nvariance_loss    :: Fraction of variance loss when performing PCA.\ntikhonov_noise   :: Tikhonov regularization factor for covariance matrices.\ntikhonov_mode    :: If \"relative\", tikhonov_noise is scaled by the maximum  eigenvalue in the covariance matrix considered, having the interpretation of  the inverse of the desired condition number. This value is enforced to be  larger than the sqrt of the machine precision for stability.\ndim_scaling      :: Whether to scale covariance blocks by their size.\ny_type           :: Type of reference mean data. Either LES() or SCM().\nΣ_type           :: Type of reference covariance data. Either LES() or SCM().\nΔt               :: [LES last time - SCM start time (LES timeframe)] for LES_driven_SCM cases.\nmodel_errors     :: Vector of model errors added to the internal variability noise, each containing                          the model error per variable normalized by the pooled variable variance.\n\n\n\n\n\n","category":"type"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.get_obs","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.get_obs","text":"get_obs(m::ReferenceModel, y_names, Σ_names, normalize; [z_scm])\nget_obs(m::ReferenceModel, y_type, Σ_type, normalize; [z_scm])\n\nGet observational mean y and empirical time covariance Σ for the ReferenceModel m.\n\nTypically, the observations are fetched by specifying y_type and Σ_type, which indicate if the data is generated by the SCM or LES. Alternatively, vectors of variable names, y_names, Σ_names, can be specified directly. Note: Σ_names may be different than y_names if there are LES/SCM name discrepancies.\n\nThe keyword normalize specifies whether observations are to be normalized with respect to the  per-quantity pooled variance or not. See normalize_profile for details. The normalization vector is return along with y and Σ.\n\nIf z_scm is given, interpolate observations to the given levels.\n\nArguments\n\nm            :: A ReferenceModel](@ref)\ny_names      :: Names of observed fields from the ReferenceModel m.\nΣ_names      :: Names of fields used to construct covariances, may be different than y_names   if there are LES/SCM name discrepancies.\nnormalize    :: Whether to normalize the observations.\ny_type       :: ModelType used to construct observations, ::LES or ::SCM.\ny_type       :: ModelType used to construct noise covariances, ::LES or ::SCM.\n\nKeywords\n\nz_scm        :: If given, interpolate LES observations to given array of vertical levels.\nmodel_error  :: Model error per variable, added to the internal variability noise, and                   normalized by the pooled variance of the variable.\n\nReturns\n\ny::Vector           :: Mean of observations y, possibly interpolated to z_scm levels.\nΣ::Matrix           :: Observational covariance matrix Σ, possibly pool-normalized.\nnorm_vec::Vector    :: Vertically averaged time-variance, one entry for each variable\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.obs_PCA","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.obs_PCA","text":"obs_PCA(y_mean, y_var, allowed_var_loss = 1.0e-1)\n\nPerform dimensionality reduction using principal component analysis on the variance y_var. Only eigenvectors with eigenvalues that contribute to the leading 1-allowed_var_loss variance are retained. Inputs:\n\ny_mean           :: Mean of the observations.\ny_var            :: Variance of the observations.\nallowed_var_loss :: Maximum variance loss allowed.\n\nOutputs:\n\ny_pca            :: Projection of y_mean onto principal subspace spanned by eigenvectors.\ny_var_pca        :: Projection of y_var on principal subspace.\nP_pca            :: Projection matrix onto principal subspace, with leading eigenvectors as columns.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.pca","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.pca","text":"pca(covmat::AbstractMatrix{FT}, allowed_var_loss::FT) where {FT <: Real}\n\nPerform dimensionality reduction using principal component analysis on the variance covmat.\n\nInputs:\n\ncovmat           :: Variance of the observations.\nallowed_var_loss :: Maximum variance loss allowed.\n\nOutputs:\n\nλ_pca            :: Principal eigenvalues, ordered in increasing value order.\nP_pca            :: Projection matrix onto principal subspace, with leading eigenvectors as columns.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.pca_length","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.pca_length","text":"Returns dimensionality of the ReferenceStatistics in low-dimensional latent space\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.full_length","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.full_length","text":"Returns full dimensionality of the ReferenceStatistics, before latent space encoding\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.get_profile","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.get_profile","text":"get_profile(\n    filename::String,\n    y_names::Vector{String};\n    ti::Real = 0.0,\n    tf::OptReal = nothing,\n    z_scm::Union{Vector{T}, T} = nothing,\n    prof_ind::Bool = false,\n) where {T}\nget_profile(\n    m::ReferenceModel,\n    filename::String;\n    z_scm::Union{Vector{T}, T} = nothing,\n    prof_ind::Bool = false,\n) where {T}\nget_profile(\n    m::ReferenceModel,\n    filename::String,\n    y_names::Vector{String};\n    z_scm::Union{Vector{T}, T} = nothing,\n    prof_ind::Bool = false,\n) where {T}\n\nGet time-averaged profiles for variables y_names, interpolated to z_scm (if given), and concatenated into a single output vector.\n\nInputs:\n\nfilename    :: nc filename\ny_names     :: Names of variables to be retrieved.\nti          :: Initial time of averaging window.\ntf          :: Final time of averaging window.\nz_scm       :: If given, interpolate LES observations to given levels.\nm           :: ReferenceModel from which to fetch profiles, implicitly defines ti and tf.\nprof_ind    :: Whether to return a boolean array indicating the variables that are profiles (i.e., not scalars). \n\nOutputs:\n\ny :: Output vector used in the inverse problem, which concatenates the requested profiles.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.get_time_covariance","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.get_time_covariance","text":"get_time_covariance(\n    m::ReferenceModel,\n    y_names::Vector{String},\n    z_scm::Vector{FT};\n    normalize::Bool = true,\n    model_error::OptVec{FT} = nothing,\n) where {FT <: Real}\n\nObtain the covariance matrix of a group of profiles, where the covariance is obtained in time.\n\nInputs:\n\nm            :: Reference model.\ny_names      :: List of variable names to be included.\nz_scm        :: If given, interpolates covariance matrix to this locations.\nnormalize    :: Whether to normalize the time series with the pooled variance      before computing the covariance, or not.\nmodel_error  :: Model error per variable, added to the internal variability noise, and                  normalized by the pooled variance of the variable.\n\n\n\n\n\n","category":"function"},{"location":"installation/#Installation-instructions","page":"Installation instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"CalibrateEDMF.jl is a registered Julia package. You can install the latest version of CalibrateEDMF.jl through the built-in package manager. Initiate a julia session and run the commands","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"julia> ]\n(v1.5) pkg> add CalibrateEDMF\n(v1.5) pkg> instantiate","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"If you want to use the latest version of the package instead, clone the GitHub repository","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"> git clone https://github.com/CliMA/CalibrateEDMF.jl.git","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"In order to use the package, compile the project first.","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"> julia --project\njulia> ]\n(v1.5) pkg> instantiate","category":"page"},{"location":"installation/#Installation-in-dev-mode-(advanced)","page":"Installation instructions","title":"Installation in dev mode (advanced)","text":"","category":"section"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"Since both TurbulenceConvection.jl and EnsembleKalmanProcesses.jl are under rapid development, we may want to access a recent unpublished version of these packages when working with CalibrateEDMF.jl, or even use a version with local changes. If this is the case, clone the latest EnsembleKalmanProcesses.jl (resp. EnsembleKalmanProcesses.jl) version from GitHub (whichever you want to dev with),","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"> git clone https://github.com/CliMA/EnsembleKalmanProcesses.jl.git\n> git clone https://github.com/CliMA/TurbulenceConvection.jl ","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"and try the following,","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"> julia --project\njulia> ]\npkg> dev path/to/EnsembleKalmanProcesses.jl path/to/TurbulenceConvection.jl\npkg> instantiate","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"This will link CalibrateEDMF to your local version of EnsembleKalmanProcesses.jl (resp. EnsembleKalmanProcesses.jl), allowing rapid prototyping across packages.","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"If you want to use PyPlot with CalibrateEDMF.jl, and you are using PyPlot for the first time, just do","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"> julia --project","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"using Pkg\nENV[\"PYTHON\"]=\"\"\nPkg.build(\"PyCall\")\nexit()","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"And then compile,","category":"page"},{"location":"installation/","page":"Installation instructions","title":"Installation instructions","text":"> julia --project -e 'using Pkg; Pkg.instantiate(); Pkg.API.precompile()'","category":"page"},{"location":"API/TurbulenceConvectionUtils/#TurbulenceConvectionUtils","page":"TurbulenceConvectionUtils","title":"TurbulenceConvectionUtils","text":"","category":"section"},{"location":"API/TurbulenceConvectionUtils/","page":"TurbulenceConvectionUtils","title":"TurbulenceConvectionUtils","text":"CurrentModule = CalibrateEDMF.TurbulenceConvectionUtils","category":"page"},{"location":"API/TurbulenceConvectionUtils/","page":"TurbulenceConvectionUtils","title":"TurbulenceConvectionUtils","text":"ModelEvaluator\nrun_SCM\nrun_reference_SCM\neval_single_ref_model\nrun_SCM_handler\ncreate_parameter_vectors\ngenerate_scm_input\nparse_version_inds\nprecondition\nget_gcm_les_uuid\nsave_tc_data","category":"page"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.ModelEvaluator","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.ModelEvaluator","text":"ModelEvaluator\n\nA structure containing the information required to perform a forward model evaluation at a given parameter vector.\n\nFields\n\nparam_cons::Vector{FT} where FT<:Real\nParameter vector in constrained (i.e. physical) space\nparam_names::Vector{String}\nParameter names associated with parameter vector\nparam_map::CalibrateEDMF.HelperFuncs.ParameterMap\nA mapping operator to define relations between parameters.      See ParameterMap for details.\nref_models::Vector{CalibrateEDMF.ReferenceModels.ReferenceModel}\nVector of reference models\nref_stats::CalibrateEDMF.ReferenceStats.ReferenceStatistics\nReference statistics for the inverse problem\n\nConstructors\n\nModelEvaluator(param_cons, param_names, param_map, RM, RS)\n\ndefined at /home/runner/work/CalibrateEDMF.jl/CalibrateEDMF.jl/src/TurbulenceConvectionUtils.jl:63.\n\nModelEvaluator(; param_cons, param_names, param_map, ref_models, ref_stats)\n\n\n\n\n\n","category":"type"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.run_SCM","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.run_SCM","text":"run_SCM(\n    u::Vector{FT},\n    u_names::Vector{String},\n    param_map::ParameterMap,\n    RM::Vector{ReferenceModel},\n    RS::ReferenceStatistics;\n    error_check::Bool = false,\n    failure_handler = \"high_loss\",\n) where {FT <: Real}\nrun_SCM(\n    ME::ModelEvaluator;\n    error_check::Bool = false,\n    failure_handler = \"high_loss\",\n) where {FT <: Real}\n\nRun the single-column model (SCM) using a set of parameters and return the value of outputs defined in y_names, possibly after normalization and projection onto lower dimensional space using PCA.\n\nThe function also outputs a boolean diagnosing whether the requested SCM simulation failed.\n\nInputs:\n\nu               :: Values of parameters to be used in simulations.\nu_names         :: SCM names for parameters u.\nparam_map       :: A mapping operator to define relations between parameters.                      See ParameterMap for details.\nRM              :: Vector of ReferenceModels\nRS              :: reference statistics for simulation\nerror_check     :: Returns as an additional argument whether the SCM call errored.\nfailure_handler :: Method used to handle failed simulations.\n\nOutputs:\n\nsim_dirs    :: Vector of simulation output directories\ng_scm       :: Vector of model evaluations concatenated for all flow configurations.\ng_scm_pca   :: Projection of g_scm onto principal subspace spanned by eigenvectors.\nmodel_error :: Whether the simulation errored with the requested configuration.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.run_reference_SCM","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.run_reference_SCM","text":"run_reference_SCM(m::ReferenceModel; overwrite::Bool = false, run_single_timestep = true)\n\nRun the single-column model (SCM) for a reference model object using default parameters, and write the output to file.\n\nInputs:\n\nm                    :: A ReferenceModel.\noverwrite            :: if true, run TC.jl and overwrite existing simulation files.\nrun_single_timestep  :: if true, run only one time step.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.eval_single_ref_model","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.eval_single_ref_model","text":"eval_single_ref_model(\n    m_index::IT,\n    m::ReferenceModel,\n    RS::ReferenceStatistics,\n    u::Vector{FT},\n    u_names::Vector{String},\n    param_map::ParameterMap,\n) where {FT <: Real, IT <: Int}\n\nRuns the single-column model (SCM) under a single configuration (i.e., ReferenceModel) using a set of parameters u, and returns the forward model evaluation in both the original and the latent PCA space.\n\nInputs:\n\nm_index       :: The index of the ReferenceModel within the overarching                  ref_models vector used to construct the ReferenceStatistics.\nm             :: A ReferenceModel.\nRS            :: reference statistics for simulation\nu             :: Values of parameters to be used in simulations.\nu_names       :: SCM names for parameters u.\nparam_map     :: A mapping operator to define relations between parameters.                      See ParameterMap for details.\n\nOutputs:\n\nsim_dir     ::  Simulation output directory.\ng_scm       :: Forward model evaluation in original output space.\ng_scm_pca   :: Projection of g_scm onto principal subspace spanned by eigenvectors.\nmodel_error :: Whether the simulation errored with the requested configuration.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.run_SCM_handler","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.run_SCM_handler","text":"run_SCM_handler(\n    m::ReferenceModel,\n    tmpdir::String,\n    u::Array{FT, 1},\n    u_names::Array{String, 1},\n    param_map::ParameterMap,\n) where {FT<:AbstractFloat}\n\nRun a case using a set of parameters u_names with values u, and return directory pointing to where data is stored for simulation run.\n\nInputs:\n\nm             :: Reference model\ntmpdir        :: Temporary directory to store simulation results in\nu             :: Values of parameters to be used in simulations.\nu_names       :: SCM names for parameters u.\nparam_map   :: A mapping operator to define relations between parameters.                  See ParameterMap for details.\n\nOutputs:\n\noutput_dir   :: directory containing output data from the SCM run.\nmodel_error   :: Boolean specifying whether the simulation failed.\n\n\n\n\n\nrun_SCM_handler(\n    case_name::String,\n    out_dir::String;\n    u::Vector{FT},\n    u_names::Vector{String},\n    param_map::ParameterMap,\n    namelist::Dict,\n    uuid::String = \"01\",\n    les::Union{NamedTuple, String} = nothing,\n)\n\nRun a TurbulenceConvection.jl case and return directory pointing to where data is stored for simulation run.\n\nInputs:\n\ncase_name     :: case name\nout_dir       :: Directory to store simulation results in.\n\nOptional Inputs:\n\nu             :: Values of parameters to be used in simulations.\nu_names       :: SCM names for parameters u.\nparam_map   :: A mapping operator to define relations between parameters.                  See ParameterMap for details.\nnamelist      :: namelist to use for simulation.\nuuid          :: uuid of SCM run\nles           :: path to LES stats file, or NamedTuple with keywords {forcingmodel, month, experiment, cfsitenumber} needed to specify path. \n\nOutputs:\n\noutput_dir   :: directory containing output data from the SCM run.\nmodel_error   :: Boolean specifying whether the simulation failed.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.create_parameter_vectors","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.create_parameter_vectors","text":"create_parameter_vectors(u_names, u, param_map, namelist)\n\nGiven vector of parameter names and corresponding values, combine any vector components into single parameter vectors for input into SCM.\n\nInputs:\n\nu_names :: SCM names for parameters u, which may contain vector components.\nu :: Values of parameters to be used in simulations, which may contain vector components.\nparam_map :: A mapping to a reduced parameter set. See ParameterMap for details.\nnamelist :: The parameter namelist for TurbulenceConvection.jl\n\nOutputs:\n\nu_names_out :: SCM names for parameters u.\nu_out :: Values of parameters to be used in simulations.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.generate_scm_input","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.generate_scm_input","text":"generate_scm_input(model_evaluators, iteration, outdir_path = pwd(), batch_indices = nothing)\n\nWrites to file a set of ModelEvaluator used to initialize SCM evaluations at different parameter vectors, as well as their assigned version, which is on the form i<iteration>_e<ensemble_index>.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.parse_version_inds","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.parse_version_inds","text":"parse_version_inds(version)\n\nGiven version = \"ix_ey\", return the iteration index x and ensemble index y as integers.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.precondition","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.precondition","text":"precondition(\n    param::Vector{FT},\n    priors,\n    param_map::ParameterMap,\n    ref_models::Vector{ReferenceModel},\n    ref_stats::ReferenceStatistics;\n    counter::Integer = 0,\n    max_counter::Integer = 10,\n) where {FT <: Real}\n\nSubstitute parameter vector param by a parameter vector drawn from the same prior, conditioned on the forward model being stable.\n\nInputs:\n\nparam          :: A parameter vector that may possibly result in unstable                      forward model evaluations (in unconstrained space).\npriors         :: Priors from which the parameters were drawn.\nparam_map      :: A mapping to a reduced parameter set. See ParameterMap for details.\nref_models     :: Vector of ReferenceModels to check stability for.\nref_stats      :: ReferenceStatistics of the ReferenceModels.\ncounter        :: Accumulator tracking number of recursive calls to preconditioner.\nmax_counter    :: Maximum number of recursive calls to the preconditioner.\n\nOutputs:\n\nnew_param :: A new parameter vector drawn from the prior, conditioned on simulations being stable (in unconstrained space).\n\n\n\n\n\nprecondition(ME::ModelEvaluator, priors)\n\nSubstitute the parameter vector of a ModelEvaluator by another one drawn from the given priors, conditioned on the forward model being stable.\n\nInputs:\n\nME          :: A ModelEvaluator.\npriors      :: Priors from which the parameters were drawn.\n\nOutputs:\n\nA preconditioned ModelEvaluator.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.get_gcm_les_uuid","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.get_gcm_les_uuid","text":"get_gcm_les_uuid(cfsite_number; [forcing_model::String, month, experiment])\n\nGenerate unique and self-describing uuid given information about a GCM-driven LES simulation from Zhaoyi Shen, Akshay Sridhar, Zhihong Tan, Anna Jaruga, Tapio Schneider (2022).\n\nExamples\n\njulia> get_gcm_les_uuid(1; forcing_model = \"HadGEM2-A\", month = 7, experiment = \"amip\")\n\"1_HadGEM2-A_07_amip\"\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.save_tc_data","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.save_tc_data","text":"save_tc_data(cases, outdir_path, sim_dirs, version, suffix)\n\nSave full TC.jl output in <results_folder>/timeseries.<suffix>/iter_<iteration>/Output.<case>.<case_id>_<ens_i>.\n\nBehavior of this function is specified in the output config, i.e. config[\"output\"]. If the flag save_tc_output is set to true, TC.jl output is saved, and if additionally a list of iterations is specified in save_tc_iterations, only these EKP iterations are saved.\n\nArguments:\n\nconfig      :: The calibration config dictionary.   To save TC.jl output, set save_tc_output to true in the output config.   To only save specific EKP iterations, specify these in a vector in save_tc_iterations in the output config.\noutdir_path :: The results results_folder path\nsim_dirs    :: List of (temporary) directories where raw simulation output is initially saved to\nversion     :: An identifier for the current iteration and ensemble index\nsuffix      :: Case set identifier; is either \"train\" or \"validation\".\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#DistributionUtils","page":"DistributionUtils","title":"DistributionUtils","text":"","category":"section"},{"location":"API/DistributionUtils/","page":"DistributionUtils","title":"DistributionUtils","text":"CurrentModule = CalibrateEDMF.DistributionUtils","category":"page"},{"location":"API/DistributionUtils/","page":"DistributionUtils","title":"DistributionUtils","text":"construct_priors\nconstruct_prior\nflatten_config_dict\nflat_dict_keys_where\nlogmean_and_logstd\nmean_and_std_from_ln","category":"page"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.construct_priors","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.construct_priors","text":"construct_priors(\n    const_dict::Dict{String, T};\n    unconstrained_σ::FT = 1.0,\n    prior_mean::Union{Dict{String, Vector{Float64}}, Nothing} = nothing,\n    outdir_path::String = pwd(),\n    to_file::Bool = true,\n) where {T, FT}\n\nDefine a prior Gaussian ParameterDistribution in unconstrained space from a dictionary of constraints.\n\nThis constructor assumes independent priors and the same unconstrained standard deviation for each parameter. Note that the standard deviation in unconstrained space is normalized with respect to the constrained interval width, so it automatically takes into account parameter scales.\n\nThe constructor also allows passing a prior mean for each parameter in constrained space.\n\nInputs:\n\nconst_dict :: Dictionary of parameter names to constraints.\nunconstrained_σ :: Standard deviation of the transformed gaussians (unconstrained space).\nprior_mean :: The mean value of the prior in constrained space. If not given,  the prior is selected to be 0 in the centered unconstrained space.\noutdir_path :: Output path.\nto_file :: Whether to write the serialized prior to a JLD2 file.\n\nOutput:\n\nThe prior ParameterDistribution.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.construct_prior","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.construct_prior","text":"construct_prior(\n    param_name::String,\n    constraint::Vector{CT},\n    prior_μ::OptVec{FT},\n    unconstrained_σ,\n) where {CT, FT <: Real}\n\nDefine a prior Gaussian ParameterDistribution in unconstrained space from a constraint, a prior in constrained space, and the standard deviation in unconstrained space.\n\nThe standard deviation in unconstrained space is normalized with respect to the constrained interval width, so it automatically takes into account parameter scales.\n\nInputs:\n\nparam_name :: A parameter name.\nconstraint :: A 1-element vector containing the constraints.\nprior_μ :: A 1-element vector containing the constrained prior mean.\nunconstrained_σ :: Standard deviation of the transformed gaussians (unconstrained space).\n\nOutput:\n\nThe prior ParameterDistribution.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.flatten_config_dict","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.flatten_config_dict","text":"flatten_config_dict(param_dict::Dict{String, Vector{T}})\n\nGiven a dictionary of parameter names to parameter vectors of arbitrary length, return a new dictionary that maps a unique parameter name to each element of the full flattened vector of parameters.\n\nInputs:\n\nparam_dict :: Dictionary of parameter names to constraints.\n\nOutputs:\n\nu_names :: Vector{String} :: vector of parameter names\nvalues :: Vector{Vector{T}} :: vector of single-valued vectors encapsulating parameter values.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.flat_dict_keys_where","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.flat_dict_keys_where","text":"flat_dict_keys_where(dict::Dict{String, Vector{T}}, condition::Function = identity) where {T}\n\nFlattens the values of a dictionary with parameter vectors as keys, and returns the indices of entries in the flattened dictionary satisfying a given condition.\n\nInputs:     param_dict :: Dictionary of parameter names to vectors.     condition :: A condition function operating on each dictionary value. Outputs:     Indices of flattened entries satisfying the condition.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.logmean_and_logstd","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.logmean_and_logstd","text":"logmean_and_logstd(μ, σ)\n\nReturns the lognormal parameters μ and σ from the mean μ and std σ of the lognormal distribution.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.mean_and_std_from_ln","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.mean_and_std_from_ln","text":"mean_and_std_from_ln(μ, σ)\n\nReturns the mean and variance of the lognormal distribution from the lognormal parameters μ and σ.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"CurrentModule = CalibrateEDMF.Diagnostics","category":"page"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"This module defines and implements diagnostics of the training process. Diagnostics are organized into groups (defined as dictionaries io_dictionary_...) and written to file in netCDF4 format. All implemented dictionaries, as well as all their entries, are defined below. These include error metrics, parameter ensembles and their statistical moments, validation diagnostics, and more. ","category":"page"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"The diagnostics are meant to evolve organically as users require more information regarding the training process. If you can think of diagnostics that may be useful to a wide range of users, consider opening an issue or pull request on GitHub.","category":"page"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Data within the resulting Diagnostics.nc file can be analyzed using the Julia package NCDatasets.jl. The file can also be processed using software written in other popular programming languages like python through netCDF4-python or xarray.","category":"page"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"io_dictionary_metrics\nio_dictionary_val_metrics\nio_dictionary_ensemble\nio_dictionary_particle_state\nio_dictionary_particle_eval\nio_dictionary_val_particle_eval\nio_dictionary_reference\nio_dictionary_val_reference\nio_dictionary_prior\nget_ϕ_cov\nget_metric_var\nget_mean_nearest_neighbor\ncompute_ensemble_loss","category":"page"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_metrics","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_metrics","text":"io_dictionary_metrics()\nio_dictionary_metrics(ekp::EnsembleKalmanProcess, mse_full::Vector{FT}) where {FT <: Real}\n\nScalar metrics dictionary.\n\nEvaluations of the data-model mismatch in inverse problem (i.e., latent) space are denoted loss. Errors computed in normalized physical (i.e., full) space are denoted mse_full. Differences between these two metrics include:\n\nCovariance matrix defining the inner product (covariance weighting in loss vs L2 norm in mse_full),\nTreatment of trailing eigenvalues (truncation and regularization vs considering all eigenmodes).\nThe loss includes the L2 penalty term, mse_full does not.\n\nElements:\n\nloss_mean_g :: (ḡ - y)'Γ_inv(ḡ - y). This is the ensemble mean loss seen by the Kalman inversion process.\nloss_mean :: Ensemble mean of (g - y)'Γ_inv(g - y).\nloss_min :: Ensemble min of (g - y)'Γ_inv(g - y).\nloss_max :: Ensemble max of (g - y)'Γ_inv(g - y).\nloss_var :: Variance estimate of (g - y)'Γ_inv(g - y), empirical (EKI/EKS) or quadrature (UKI).\nloss_nn_mean :: (g_nn - y)'Γ_inv(nn - y), where g_nn is the forward model output at the particle closest to the mean in parameter space.\nmse_full_mean :: Ensemble mean of MSE(g_full, y_full).\nmse_full_min :: Ensemble min of MSE(g_full, y_full).\nmse_full_max :: Ensemble max of MSE(g_full, y_full).\nmse_full_var :: Variance estimate of MSE(g_full, y_full), empirical (EKI/EKS) or quadrature (UKI).\nmse_full_nn_mean :: MSE(g_full, y_full) of particle closest to the mean in parameter space. The mean in parameter space is the solution to the particle-based inversion.\nfailures :: Number of particle failures per iteration. If the calibration is run with the \"high_loss\" failure handler, this diagnostic will not capture the failures due to parameter mapping.\nnn_mean_index :: Particle index of the nearest neighbor to the ensemble mean in parameter space. This index is used to construct ..._nn_mean metrics.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_val_metrics","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_val_metrics","text":"io_dictionary_val_metrics()\nio_dictionary_val_metrics(ekp::EnsembleKalmanProcess, mse_full::Vector{FT}) where {FT <: Real}\n\nDictionary of scalar validation metrics.\n\nEvaluations of the data-model mismatch in inverse problem (i.e., latent) space are denoted loss. Errors computed in normalized physical (i.e., full) space are denoted mse_full. Differences between these two metrics include:\n\nCovariance matrix defining the inner product (covariance weighting in loss vs L2 norm in mse_full),\nTreatment of trailing eigenvalues (truncation and regularization vs considering all eigenmodes).\nThe loss includes the L2 penalty term, mse_full does not.\n\nElements:\n\nval_loss_mean :: Ensemble mean of validation (g - y)'Γ_inv(g - y).\nval_loss_min :: Ensemble min of validation (g - y)'Γ_inv(g - y).\nval_loss_max :: Ensemble max of validation (g - y)'Γ_inv(g - y).\nval_loss_var :: Variance estimate of validation (g - y)'Γ_inv(g - y), empirical (EKI/EKS) or quadrature (UKI).\nval_loss_nn_mean :: Validation (g_nn - y)'Γ_inv(nn - y), where g_nn is the validation forward model output at the particle closest to the mean in parameter space.\nval_mse_full_mean :: Ensemble mean of MSE(g_full_val, y_full_val).\nval_mse_full_min :: Ensemble min of MSE(g_full_val, y_full_val).\nval_mse_full_max :: Ensemble max of MSE(g_full_val, y_full_val).\nval_mse_full_var :: Variance estimate of MSE(g_full_val, y_full_val), empirical (EKI/EKS) or quadrature (UKI).\nval_mse_full_nn_mean :: MSE(g_full_val, y_full_val) of particle closest to the mean in parameter space. The mean in parameter space is the solution to the particle-based inversion.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_ensemble","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_ensemble","text":"io_dictionary_ensemble()\nio_dictionary_ensemble(ekp::EnsembleKalmanProcess, priors::ParameterDistribution)\n\nDictionary of ensemble parameter diagnostics.\n\nElements:\n\nu_mean :: Ensemble mean parameter in unconstrained (inverse problem) space.\nphi_mean :: Ensemble mean parameter in constrained (physical) space.\nu_cov :: Sample parameter covariance in unconstrained (inverse problem) space.\nphi_cov :: Sample parameter covariance in constrained (physical) space.\nphi_low_unc :: Lower uncertainty bound (μ-1σ) of the parameter value in constrained (physical) space.\nphi_upp_unc :: Upper uncertainty bound (μ+1σ) of the parameter value in constrained (physical) space.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_particle_state","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_particle_state","text":"io_dictionary_particle_state()\nio_dictionary_particle_state(ekp::EnsembleKalmanProcess, priors::ParameterDistribution)\n\nDictionary of particle-wise parameter diagnostics, not involving forward model evaluations.\n\nElements:\n\nu   :: Parameter ensemble in unconstrained (inverse problem) space.\nphi :: Parameter ensemble in constrained (physical) space.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_particle_eval","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_particle_eval","text":"io_dictionary_particle_eval()\nio_dictionary_particle_eval(\n    ekp::EnsembleKalmanProcess,\n    g_full::Matrix{FT},\n    mse_full::Vector{FT},\n    d::IT,\n    d_full::IT,\n    batch_indices::Vector{IT},\n) where {FT <: Real, IT <: Integer}\n\nDictionary of particle-wise diagnostics involving forward model evaluations.\n\nElements:\n\ng :: Forward model evaluation in inverse problem space.\ng_full :: Forward model evaluation in primitive output space, normalized using the pooled field covariance.\nmse_full :: Particle-wise evaluation of MSE(g_full, y_full).\nbatch_indices :: Indices of ReferenceModels evaluated per iteration.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_val_particle_eval","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_val_particle_eval","text":"io_dictionary_val_particle_eval()\nio_dictionary_val_particle_eval(\n    g::Matrix{FT},\n    g_full::Matrix{FT},\n    mse_full::Vector{FT},\n    d::IT,\n    d_full::IT,\n    batch_indices::Vector{IT},\n) where {FT <: Real, IT <: Integer}\n\nDictionary of particle-wise validation diagnostics involving forward model evaluations.\n\nElements:\n\nval_g :: Validation forward model evaluation in reduced space.\nval_g_full :: Validation forward model evaluation in primitive output space, normalized using the pooled field covariance.\nval_mse_full :: Particle-wise evaluation of MSE(val_g_full, val_y_full).\nval_batch_indices :: Indices of validation ReferenceModels evaluated per iteration.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_reference","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_reference","text":"io_dictionary_reference()\nio_dictionary_reference(\n    ref_stats::ReferenceStatistics,\n    ref_models::Vector{ReferenceModel},\n    write_full_stats::Bool = true,\n)\n\nDictionary of diagnostics pertaining to the ReferenceModels and ReferenceStatistics that define the inverse problem.\n\nElements:\n\nGamma :: Covariance matrix in the inverse problem latent space (regularized low-dimensional encoding).\nGamma_full :: Covariance matrix of normalized observed variables in full space (possibly ill-conditioned). Only written to file if write_full_stats is true.\nGamma_full_diag :: Diagonal of Gamma_full, useful when Gamma_full is not written to file.\ny :: Observations in the inverse problem latent space (low-dimensional encoding).\ny_full :: Normalized observations in full space.\nP_pca :: PCA projection matrix from full space to low-dimensional latent space.\nnum_vars :: Maximum number of observed fields (not dimensions) per ReferenceModel.\nvar_dof :: Maximum number of degrees of freedom of each field per ReferenceModel.\nconfig_pca_dim :: Dimensionality of the latent space associated with each ReferenceModel.\nconfig_name :: Name of each ReferenceModel used to construct the inverse problem.\nconfig_z_obs :: Vertical locations of the observations of each ReferenceModel.\nnorm_factor :: Pooled variance used to normalize each field of each ReferenceModel.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_val_reference","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_val_reference","text":"io_dictionary_val_reference()\nio_dictionary_val_reference(\n    ref_stats::ReferenceStatistics,\n    ref_models::Vector{ReferenceModel},\n    write_full_stats::Bool = true,\n)\n\nDictionary of diagnostics pertaining to the ReferenceModels and ReferenceStatistics in the validation set.\n\nElements:\n\nGamma_val :: Covariance matrix in latent space, using the same truncation as for the training set.\nGamma_full_val :: Covariance matrix of normalized observed variables in full space. Only written to file if write_full_stats is true.\nGamma_full_diag_val :: Diagonal of Gamma_full_val, useful when Gamma_full_val is not written to file.\ny_val :: Observations in latent space, for observed fields in the validation set.\ny_full_val :: Normalized observations in full space, for the validation set.\nP_pca_val :: PCA projection matrix from full space to low-dimensional latent space, for the validation set.\nnum_vars_val :: Maximum number of observed fields (not dimensions) per validation ReferenceModel.\nvar_dof_val :: Maximum number of degrees of freedom of each field per validation ReferenceModel.\nconfig_pca_dim_val :: Dimensionality of the latent space associated with each validation ReferenceModel.\nconfig_name_val :: Name of each ReferenceModel in the validation set.\nconfig_z_obs_val :: Vertical locations of the observations of each validation ReferenceModel.\nnorm_factor_val :: Pooled variance used to normalize each field of each validation ReferenceModel.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_prior","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_prior","text":"io_dictionary_prior()\nio_dictionary_prior(priors::ParameterDistribution)\n\nParameter prior diagnostics dictionary.\n\nElements:\n\nu_mean_prior :: Prior mean in unconstrained parameter space.\nphi_mean_prior :: Prior mean in constrained parameter space.\nu_var_prior :: Diagonal of the prior covariance in unconstrained space.\nphi_low_unc_prior :: Lower uncertainty bound (μ-1σ_prior) of prior in constrained space.\nphi_upp_unc_prior :: Upper uncertainty bound (μ+1σ_prior) of prior in constrained space.\nphi_low_std_prior :: Lower standard bound (μ-1) of prior in constrained space. Useful measure of minimum allowed values for bounded parameters.\nphi_upp_std_prior :: Upper standard bound (μ+1) of prior in constrained space. Useful measure of maximum allowed values for bounded parameters.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.get_ϕ_cov","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.get_ϕ_cov","text":"get_ϕ_cov(ekp::EnsembleKalmanProcess, priors::ParameterDistribution)\n\nGet the last parameter covariance estimate in constrained (physical) space.\n\nFor ensemble methods, the covariance of the transformed parameters is returned. For unscented methods, the covariance is computed through a quadrature on the transformed quadrature points. The covariance of the transformed parameters returned here is equal to the transformed covariance only under a first order Taylor approximation, which is consistent with other approximations underlying the calibration method.\n\nInputs:\n\nekp    :: The EnsembleKalmanProcess.\npriors :: The priors defining transformations between constrained and unconstrained space.\n\nOutputs:\n\nThe parameter covariance in constrained space.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.get_metric_var","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.get_metric_var","text":"get_metric_var(ekp::EnsembleKalmanProcess, metric::Vector{FT}) where {FT <: Real}\n\nComputes the ensemble variance of a scalar metric.\n\nFor ensemble methods, the sample variance of the metric is returned. For unscented methods, the variance is computed through a quadrature. Ensemble members where the metric is NaN are filtered out of the computation.\n\nInputs:\n\nekp    :: The EnsembleKalmanProcess.\nmetric :: A vector containing the value of the metric for each ensemble member.\n\nOutputs:\n\nThe ensemble variance of metric.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.get_mean_nearest_neighbor","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.get_mean_nearest_neighbor","text":"get_mean_nearest_neighbor(ekp::EnsembleKalmanProcess)\n\nReturns the index of the nearest neighbor to the ensemble mean parameter, in unconstrained space.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.compute_ensemble_loss","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.compute_ensemble_loss","text":"compute_ensemble_loss(\n    g::AbstractMatrix{FT},\n    y::AbstractVector{FT},\n    Γ::Union{AbstractMatrix{FT}, UniformScaling{FT}},\n) where {FT <: Real}\ncompute_ensemble_loss(ekp::EnsembleKalmanProcess)\n\nComputes the covariance-weighted error (g - y)'Γ_inv(g - y) for each ensemble member.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#HelperFuncs","page":"HelperFuncs","title":"HelperFuncs","text":"","category":"section"},{"location":"API/HelperFuncs/","page":"HelperFuncs","title":"HelperFuncs","text":"CurrentModule = CalibrateEDMF.HelperFuncs","category":"page"},{"location":"API/HelperFuncs/","page":"HelperFuncs","title":"HelperFuncs","text":"ParameterMap\ndo_nothing_param_map\nexpand_params\nnamelist_subdict_by_key\nvertical_interpolation\nnc_fetch_interpolate\nfetch_interpolate_transform\nget_height\nnormalize_profile\nnc_fetch\nis_face_variable\nget_stats_path\ncompute_mse\npenalize_nan\nserialize_struct\ndeserialize_struct\njld2_path\nwrite_versions\nget_entry\nchange_entry!\nupdate_namelist!\nmerge_namelist_args","category":"page"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.ParameterMap","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.ParameterMap","text":"struct ParameterMap\n\nParameterMap is a struct that defines relations between different parameters.\n\nThe dictionary mapping specifies a map from any parameter that is not being  calibrated to either a calibrated parameter, or a number.  If another parameter name is specified, the samples from that parameter's distribution is used as the given parameter's value throughout calibration, effectively defining an equivalence between the two parameters. If a number is specified, the parameter will be assigned that constant value throughout  the calibration process.\n\nThese mappings are primarily useful for vector parameters, where we can choose to only calibrate specific components of a vector parameter, or setting different components of a vector equal to other components of the vector (or to other parameters). Note, vector  components are specified by <name>_{<index>}, e.g. general_stochastic_ent_params_{3}  for the third component of the vector parameter general_stochastic_ent_params.\n\nExamples\n\nSuppose we have the parameter vector param with five components. We can choose to only calibrate the first and third component, fixing the fourth component to 3.0, and also specifying that the first and second component should be equal, in the following way:\n\njulia> param_map = ParameterMap(\n    mapping = Dict(\n        \"param_{2}\" => \"param_{1}\",\n        \"param_{4}\" => 3.0,\n    ),\n)\n\nThe parameter map should be specified in the function get_prior_config() in config.jl,\n\n# function get_prior_config()  \nconfig = Dict()\n\nconfig[\"constraints\"] = Dict(\n    \"param_{1}\" => [bounded(1.0, 2.0)],\n    \"param_{3} => [bounded(3.0, 4.0)],\n)\n\nconfig[\"param_map\"] = CalibrateEDMF.HelperFuncs.ParameterMap(\n    mapping = Dict(\n        \"param_{2}\" => \"param_{1}\",\n        \"param_{4}\" => 3.0,\n    ),\n)\n\n# ...\n# end\n\nNotice that the fifth component was neither specified in the prior, nor the mapping. This will fix that component to its default value as specified in the namelist (i.e. in TurbulenceConvection.jl).\n\n\n\n\n\n","category":"type"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.do_nothing_param_map","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.do_nothing_param_map","text":"do-nothing param_map.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.expand_params","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.expand_params","text":"expand_params(u_names_calib, u_calib, param_map, namelist)\n\nExpand a list of parameters using a param_map and a namelist.\n\nExpand a list of parameters and its corresponding values using the ParameterMap.  If u_names_calib contain vector components, fetch all unspecified components  from the namelist so that for any vector component in u_names_calib,  all other components of that vector are also specified.\n\nArguments\n\nu_names_calib: A list of parameter names that are being calibrated\nu_calib: A list of values associated with the parameter names\nparam_map: A ParameterMap specifying a parameter mapping.\nnamelist: A dictionary of default parameter values.\n\nReturns a tuple of two vectors defining parameter names and parameter values, possibly expanded relative to the input arguments to define all components of vector parameters or from relations specified by the ParameterMap.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.namelist_subdict_by_key","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.namelist_subdict_by_key","text":"namelist_subdict_by_key(namelist, param_name) -> subdict\n\nReturn the subdict of namelist that has param_name as a key.\n\nThe namelist is defined in TurbulenceConvection.jl\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.vertical_interpolation","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.vertical_interpolation","text":"vertical_interpolation(\n    var_name::String,\n    filename::String,\n    z_scm::Vector{FT};\n) where {FT <: AbstractFloat}\n\nReturns the netcdf variable var_name interpolated to heights z_scm.\n\nInputs:\n\nvar_name :: Name of variable in the netcdf dataset.\nfilename :: nc filename\nz_scm :: Vertical coordinate vector onto which var_name is interpolated.\n\nOutput:\n\nThe interpolated vector.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.nc_fetch_interpolate","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.nc_fetch_interpolate","text":"nc_fetch_interpolate(var_name::String, filename::String, z_scm::OptVec{<:Real})\n\nReturns the netcdf variable var_name, possibly interpolated to heights z_scm.\n\nInputs:\n\nvar_name :: Name of variable in the netcdf dataset.\nfilename :: nc filename\nz_scm :: Vertical coordinate vector onto which var_name is interpolated.\n\nOutput:\n\nThe interpolated vector.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.fetch_interpolate_transform","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.fetch_interpolate_transform","text":"fetch_interpolate_transform(var_name::String, filename::String, z_scm::OptVec{<:Real})\n\nReturns the netcdf variable var_name, possibly interpolated to heights z_scm. If the variable needs to be transformed to be equivalent to an SCM variable, applies the transformation as well.\n\nInputs:\n\nvar_name :: Name of variable in the netcdf dataset.\nfilename :: nc filename\nz_scm :: Vertical coordinate vector onto which var_name is interpolated.\n\nOutput:\n\nThe interpolated and transformed vector.\n\nPyCLES variables that require transformations:\n\nPyCLES diagnostic vertical fluxes (defined in AuxiliaryStatistics.pyx) are specific quantities,   not multiplied by density, and written at cell centers. These include all resolved_z_flux_(...) and   sgs_z_flux_(...) diagnostics. For instance the resolved_z_flux_theta is langlew^*theta^*rangle.   In contrast, all massflux_(...), diffusive_flux_(...) and total_flux_(...) outputs from   TC.jl are already multiplied by density and written at cell faces; e.g. total_flux_h is rholanglew^*theta^*rangle.   The location mismatch is handled through is_face_variable and interpolation. Another difference   is that the total_flux_(...) in TC.jl simulations includes the full flux, whereas the PyCLES resolved   definitions only include the resolved flux. We must add the sgs_z_flux_(...) component here.\nPyCLES prognostic vertical fluxes (defined in ScalarAdvection.pyx,   ScalarDiffusion.pyx, MomentumAdvection.pyx,   MomentumDiffusion.pyx) are defined at cell centers and have already been multiplied by density. They are computed   at cell faces in the low-level functions in scalar_advection.h and scalar_diffusion.h,   and then interpolated   in the .pyx files before they are written to file. These include all   (...)_flux_z and (...)__sgs_flux_z fluxes. In contrast, flux diagnostics from TC.jl are defined   at cell faces. This mismatch is handled through is_face_variable. Another difference is that the total_flux_(...)   in TC.jl simulations includes the full flux, whereas the PyCLES (...)_flux_z definition only includes the resolved   flux. We must add the (...)__sgs_flux_z component here.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.get_height","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.get_height","text":"get_height(filename::String; get_faces::Bool = false)\n\nReturns the vertical cell centers or faces of the given configuration.\n\nInputs:\n\nfilename :: nc filename.\nget_faces :: If true, returns the coordinates of cell faces. Otherwise,  returns the coordinates of cell centers.\n\nOutput:\n\nz: Vertical level coordinates.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.normalize_profile","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.normalize_profile","text":"normalize_profile(\n    y::Array{FT},\n    norm_vec::Array{FT},\n    prof_dof::IT,\n    prof_indices::OptVec{Bool} = nothing,\n) where {FT <: Real, IT <: Integer}\n\nPerform normalization of the aggregate observation vector y using separate normalization constants for each variable, contained in norm_vec.\n\nInputs:\n\ny :: Aggregate observation vector.\nnorm_vec :: Vector of squares of normalization factors.\nprof_dof :: Degrees of freedom of vertical profiles contained in y.\nprof_indices :: Vector of booleans specifying which variables are profiles, and which  are timeseries.\n\nOutput:\n\nThe normalized aggregate observation vector.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.nc_fetch","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.nc_fetch","text":"nc_fetch(filename::String, var_names::NTuple{N, Tuple}) where {N}\nnc_fetch(filename::String, var_name::String)\n\nReturns the data for a variable var_name (or tuple of strings, varnames), looping through all dataset groups.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.is_face_variable","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.is_face_variable","text":"is_face_variable(filename::String, var_name::String)\n\nA Bool indicating whether the given variable is defined in a face, or not (cell center).\n\nTurbulenceConvection data are consistent, meaning that variables at cell faces (resp. centers) have as dim zf (resp., zc).\n\nPyCLES variables are inconsistent. All variables have as a dim z, the cell face locations, but most of them (except for the statistical moments of w) are actually defined at cell centers (z_half). \n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.get_stats_path","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.get_stats_path","text":"get_stats_path(dir)\n\nGiven directory to standard LES or SCM output, fetch path to stats file.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.compute_mse","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.compute_mse","text":"compute_mse(g_arr::Vector{Vector{FT}}, y::Vector{FT})::Vector{FT}\ncompute_mse(g_mat::Matrix{FT}, y::Vector{FT})::Vector{FT}\n\nComputes the L2-norm error of each vector, column or row of an array with respect to a vector y.\n\nOutput:\n\nThe mse for each ensemble member.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.penalize_nan","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.penalize_nan","text":"penalize_nan(arr::Vector{FT}; penalization::FT = 1.0e5) where {FT <: AbstractFloat}\n\nSubstitutes all NaN entries in arr by a penalization factor.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.serialize_struct","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.serialize_struct","text":"serialize_struct(s::T) where {T}\n\nSerializes the given structure as a dictionary to allow storage in JLD2 format.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.deserialize_struct","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.deserialize_struct","text":"deserialize_struct(dict::Dict{String}, ::Type{T})\n\nDeserializes the given dictionary and constructs a struct of the given type with the dictionary values.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.jld2_path","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.jld2_path","text":"jld2_path(root::String, identifier::Union{String, Int}, prefix::String)\n\nGenerates a JLD2 path, given a root path, an identifier and a prefix.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.write_versions","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.write_versions","text":"write_versions(versions, iteration; outdir_path = pwd())\n\nWrites versions associated with an EnsembleKalmanProcess iteration to a text file.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.get_entry","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.get_entry","text":"get_entry(dict, key, default)\n\nCalls get but logs whether the default is used.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.change_entry!","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.change_entry!","text":"change_entry!(dict, keys_and_value)\n\nChanges the entry of a nested dictionary, given a tuple of all its keys and the new value\n\nInputs:\n\ndict           :: Parent dictionary with an arbitrary number of nested dictionaries.\nkeys_and_value :: Tuple of keys from the parent dictionary to the entry to be modified,                   and the value to use to modify it.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.update_namelist!","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.update_namelist!","text":"update_namelist!(namelist, namelist_args)\n\nUpdate namelist with arguments given by namelist_args.\n\nnamelist_args is a Vector of Tuples, where each Tuple specifies the keys to traverse the namelist, and the last element of the Tuple is the value to be set.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.merge_namelist_args","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.merge_namelist_args","text":"merge_namelist_args(args, overwrite_args)\n\nCombine two lists of namelist arguments by joining the lists, in order.\n\nThis method is intended to be used in the context of case-specific- and global namelistargs. In that case, `args = globalargsandoverwriteargs = caseargs`.\n\nEither argument can be nothing, in which case the other argument is returned; if both are nothing, return nothing.\n\nSee also update_namelist!.\n\n\n\n\n\n","category":"function"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"","category":"page"},{"location":"API/Pipeline/#Pipeline","page":"Pipeline","title":"Pipeline","text":"","category":"section"},{"location":"API/Pipeline/","page":"Pipeline","title":"Pipeline","text":"Module containing all high-level functions defining a training session workflow. User interactions should be done through the use of a config.jl file. See the experiments directory of the package for a few examples of config.jl files.","category":"page"},{"location":"API/Pipeline/","page":"Pipeline","title":"Pipeline","text":"CurrentModule = CalibrateEDMF.Pipeline","category":"page"},{"location":"API/Pipeline/","page":"Pipeline","title":"Pipeline","text":"init_calibration\nrestart_calibration\nek_update\nupdate_validation\nupdate_minibatch_inverse_problem\nwrite_model_evaluators\ninit_diagnostics\nupdate_diagnostics","category":"page"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.init_calibration","page":"Pipeline","title":"CalibrateEDMF.Pipeline.init_calibration","text":"init_calibration(job_id::String, config::Dict{Any, Any})\n\nInitializes a calibration process given a configuration, and a pipeline mode.\n\nInputs:\n\njob_id :: Unique job identifier for sbatch communication.\nconfig :: User-defined configuration dictionary.\nmode :: Whether the calibration process is parallelized through HPC resources or using Julia's pmap.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.restart_calibration","page":"Pipeline","title":"CalibrateEDMF.Pipeline.restart_calibration","text":"restart_calibration(\n    ekobj::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    last_iteration::Int64,\n    config::Dict{Any, Any},\n    outdir_path::String,\n)\n\nRestarts a calibration process from an EnsembleKalmanProcess, the parameter priors and the calibration process config file. If batching, it requires access to the last ReferenceModelBatch, stored in the results directory of the previous calibration, outdir_path.\n\nWrites to file the ModelEvaluators necessary to continue the calibration process.\n\nInputs:\n\nekobj          :: EnsembleKalmanProcess to be updated.\npriors         :: Priors over parameters, used for unconstrained-constrained mappings.\nlast_iteration :: Last iteration of the calibration process to be restarted.\nconfig         :: Configuration dictionary.\noutdir_path    :: Output path directory of the calibration process to be restarted.\nmode :: Whether the calibration process is parallelized through HPC resources or using Julia's pmap.\njob_id :: Unique job identifier for sbatch communication.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.ek_update","page":"Pipeline","title":"CalibrateEDMF.Pipeline.ek_update","text":"ek_update(\n    ekobj::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    iteration::Int64,\n    config::Dict{Any, Any},\n    versions::Vector{String},\n    outdir_path::String,\n)\n\nUpdates an EnsembleKalmanProcess using forward model evaluations stored in output files defined by their versions, and generates the parameters for the next ensemble for forward model evaluations. The updated EnsembleKalmanProcess and new ModelEvaluators are both written to file.\n\nInputs:\n\nekobj         :: EnsembleKalmanProcess to be updated.\npriors        :: Priors over parameters, used for unconstrained-constrained mappings.\niteration     :: Current iteration of the calibration process.\nconfig        :: Process configuration dictionary.\nversions      :: String versions identifying the forward model evaluations.\noutdir_path   :: Output path directory.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.update_validation","page":"Pipeline","title":"CalibrateEDMF.Pipeline.update_validation","text":"update_validation(\n    val_config::Dict{Any, Any},\n    reg_config::Dict{Any, Any},\n    ekp_old::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    param_map::ParameterMap,\n    versions::Vector{String},\n    outdir_path::String,\n    iteration::Integer\n)\n\nUpdates the validation diagnostics and writes to file the validation ModelEvaluators for the next calibration step.\n\nInputs:\n\nval_config    :: Validation model configuration.\nreg_config    :: Regularization configuration.\nekp_old       :: EnsembleKalmanProcess updated using the past forward model evaluations.\npriors        :: The priors over parameter space.\nparam_map     :: A mapping to a reduced parameter set. See ParameterMap for details.\nversions      :: String versions identifying the forward model evaluations.\noutdir_path   :: Output path directory.\niteration     :: EKP iteration\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.update_minibatch_inverse_problem","page":"Pipeline","title":"CalibrateEDMF.Pipeline.update_minibatch_inverse_problem","text":"update_minibatch_inverse_problem(\n    rm_batch::ReferenceModelBatch,\n    ekp_old::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    batch_size::Integer,\n    outdir_path::String,\n    config::Dict{Any, Any},\n)\n\nReturns the EnsembleKalmanProcess and ReferenceStatistics consistent with the new ReferenceModel minibatch, and updates the evaluation order of the ReferenceModelBatch.\n\nInputs:\n\nrm_batch    :: The global ReferenceModelBatch with the current model evaluation order.\nekp_old     :: The EnsembleKalmanProcess from the previous minibatch evaluation.\nbatch_size  :: The batch size of the current minibatch.\noutdir_path :: The output directory.\nconfig      :: The configuration dictionary.\n\nOutputs:\n\nekp             :: The EnsembleKalmanProcess for the current minibatch.\nref_models      :: The current minibatch of ReferenceModels.\nref_stats       :: The ReferenceStatistics consistent with the current minibatch.\nrefmodelbatch :: The global ReferenceModelBatch with the updated model evaluation order.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.write_model_evaluators","page":"Pipeline","title":"CalibrateEDMF.Pipeline.write_model_evaluators","text":"write_model_evaluators(\n    ekp::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    param_map::ParameterMap,\n    ref_models::Vector{ReferenceModel},\n    ref_stats::ReferenceStatistics,\n    outdir_path::String,\n    iteration::Int,\n)\n\nCreates and writes to file the ModelEvaluators for the current particle ensemble.\n\nInputs:\n\nekp         :: The EnsembleKalmanProcess with the current ensemble of parameter values.\npriors      :: The parameter priors.\nparam_map   :: A mapping to a reduced parameter set. See ParameterMap for details.\nref_models  :: The ReferenceModels defining the new model evaluations.\nref_stats   :: The ReferenceStatistics corresponding to passed ref_models.\noutdir_path :: The output directory.\niteration   :: The current process iteration.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.init_diagnostics","page":"Pipeline","title":"CalibrateEDMF.Pipeline.init_diagnostics","text":"init_diagnostics(\n    config::Dict{Any, Any},\n    outdir_path::String,\n    ref_stats::ReferenceStatistics,\n    ekp::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n)\n\nCreates a diagnostics netcdf file.\n\nInputs:\n\nconfig :: User-defined configuration dictionary.\noutdir_path :: Path of results directory.\nref_stats :: ReferenceStatistics.\nekp :: Initial EnsembleKalmanProcess, containing parameter information, but no forward model evaluations.\npriors:: Prior distributions of the parameters.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.update_diagnostics","page":"Pipeline","title":"CalibrateEDMF.Pipeline.update_diagnostics","text":"update_diagnostics(outdir_path::String, ekp::EnsembleKalmanProcess, priors::ParameterDistribution)\n\nAppends diagnostics of the current iteration evaluations (i.e., forward model output metrics) and the next iteration state (i.e., parameters and parameter metrics) to a diagnostics netcdf file.\n\nInputs:\n\noutdir_path :: Path of results directory.\nekp :: Current EnsembleKalmanProcess.\npriors:: Prior distributions of the parameters.\nref_stats :: ReferenceStatistics.\ng_full :: The forward model evaluation in primitive space.\nversions :: Version identifiers of the forward model evaluations at the current iteration.\nval_config :: The validation configuration, if given.\nbatch_indices :: The indices of the ReferenceModels used in the current batch.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#KalmanProcessUtils","page":"KalmanProcessUtils","title":"KalmanProcessUtils","text":"","category":"section"},{"location":"API/KalmanProcessUtils/","page":"KalmanProcessUtils","title":"KalmanProcessUtils","text":"CurrentModule = CalibrateEDMF.KalmanProcessUtils","category":"page"},{"location":"API/KalmanProcessUtils/","page":"KalmanProcessUtils","title":"KalmanProcessUtils","text":"PiecewiseConstantDecay\nPiecewiseConstantGrowth\nget_Δt\ngenerate_ekp\ngenerate_tekp\nget_sparse_indices\nget_regularized_indices","category":"page"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.PiecewiseConstantDecay","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.PiecewiseConstantDecay","text":"PiecewiseConstantDecay{FT <: Real, IT <: Int} <: LearningRateScheduler\n\nPiecewise constant decay learning rate scheduler.\n\nHalves the time step periodically with period τ.\n\nFields\n\nΔt_init::Real\nInitial learning rate\nτ::Int64\nHalving time\n\nConstructors\n\nPiecewiseConstantDecay(Δt_init, τ)\n\ndefined at /home/runner/work/CalibrateEDMF.jl/CalibrateEDMF.jl/src/KalmanProcessUtils.jl:47.\n\n\n\n\n\n","category":"type"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.PiecewiseConstantGrowth","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.PiecewiseConstantGrowth","text":"PiecewiseConstantGrowth{FT <: Real, IT <: Int} <: LearningRateScheduler\n\nPiecewise constant growth learning rate scheduler.\n\nDoubles the time step periodically with period τ.\n\nFields\n\nΔt_init::Real\nInitial learning rate\nτ::Int64\nDoubling time\n\nConstructors\n\nPiecewiseConstantGrowth(Δt_init, τ)\n\ndefined at /home/runner/work/CalibrateEDMF.jl/CalibrateEDMF.jl/src/KalmanProcessUtils.jl:69.\n\n\n\n\n\n","category":"type"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.get_Δt","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.get_Δt","text":"Retrieve learning rate Δt from a LearningRateScheduler\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.generate_ekp","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.generate_ekp","text":"generate_ekp(\n    ref_stats::ReferenceStatistics,\n    process::Process,\n    u::Union{Matrix{T}, T} = nothing;\n    failure_handler::String = \"ignore_failures\",\n    localizer::LocalizationMethod = NoLocalization(),\n    outdir_path::String = pwd(),\n    to_file::Bool = true,\n) where {T}\n\nGenerates, and possible writes to file, an EnsembleKalmanProcess from a parameter ensemble and reference statistics.\n\nInputs:\n\nref_stats :: ReferenceStatistics defining the inverse problem.\nprocess :: Type of EnsembleKalmanProcess used to evolve the ensemble.\nu :: An ensemble of parameter vectors, used if !isa(process, Unscented).\nfailure_handler :: String describing what failure handler to use.\nlocalizer :: Covariance localization method.\noutdir_path :: Output path.\nto_file :: Whether to write the serialized prior to a JLD2 file.\n\nOutput:\n\nThe generated EnsembleKalmanProcess.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.generate_tekp","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.generate_tekp","text":"generate_tekp(\n    ref_stats::ReferenceStatistics,\n    priors::ParameterDistribution,\n    process::Process,\n    u::Union{Matrix{T}, T} = nothing;\n    l2_reg::Union{Dict{String, Vector{R}}, R} = nothing,\n    failure_handler::String = \"ignore_failures\",\n    localizer::LocalizationMethod = NoLocalization(),\n    outdir_path::String = pwd(),\n    to_file::Bool = true,\n) where {T, R}\n\nGenerates, and possible writes to file, a Tikhonov EnsembleKalmanProcess from a parameter ensemble and reference statistics.\n\nTikhonov regularization is implemented through output state augmentation with the input parameter vector. The input L2 regularization hyperparameter should be interpreted as the inverse of the variance of our prior belief in the magnitude of the parameters.\n\nInputs:\n\nref_stats :: ReferenceStatistics defining the inverse problem.\npriors :: Parameter priors used for L2 (i.e., Tikhonov) regularization\nprocess :: Type of EnsembleKalmanProcess used to evolve the ensemble.\nu :: An ensemble of parameter vectors, used if !isa(process, Unscented).\nl2_reg :: L2 regularization hyperparameter driving parameter values toward prior.      May be a float (isotropic regularization) or a dictionary of regularizations      per parameter.\nfailure_handler :: String describing what failure handler to use.\nlocalizer :: Covariance localization method.\noutdir_path :: Output path.\nto_file :: Whether to write the serialized prior to a JLD2 file.\n\nOutput:\n\nThe generated augmented EnsembleKalmanProcess.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.get_sparse_indices","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.get_sparse_indices","text":"Returns the sparse parameter indices given the sparsity configuration and the number of parameters.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.get_regularized_indices","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.get_regularized_indices","text":"Returns the indices of parameters to be regularized, given the l2 regularization configuration dictionary.\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The main purpose of CalibrateEDMF.jl is to provide a user-friendly way to calibrate atmospheric turbulence and convection parameterizations within TurbulenceConvection.jl using gradient-free ensemble Kalman methods.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"All user directives are specified through a config.jl file. config.jl is a Julia-readable collection of nested dictionaries that define all aspects of the calibration process, including:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The data used for training and online validation,\nInverse problem and optimization regularization,\nThe algorithm used for calibration (Ensemble Kalman Inversion, Unscented Kalman Inversion, ...) and its hyperparameters,\nParameter bounds and prior distributions.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Several config.jl example files are included in the experiments/ directory of the package. The Pipeline.jl module implements the high-level functions called during a training session, from config-parsing to diagnostic output directives.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"CalibrateEDMF.jl implements several calibration pipelines, designed to exploit available parallelisms of the computing station at the user's disposal.","category":"page"},{"location":"getting_started/#Julia's-pmap()-pipeline","page":"Getting started","title":"Julia's pmap() pipeline","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"For personal computers, parallelism is implemented through Julia's pmap() function.","category":"page"},{"location":"getting_started/#How-to-run-(pmap()-pipeline)","page":"Getting started","title":"How to run (pmap() pipeline)","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Navigate to experiments/scm_pycles_pipeline/julia_parallel directory. The script calibrate.jl implements the workflow of a training session that leverages Julia's pmap() to perform parallel TurbulenceConvection.jl evaluations within each training step. Evaluations are parallelized across ensemble members. ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you are on the Caltech Central Cluster, you can run this pipeline by adding it to the SLURM schedule:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"> sbatch calibrate_script ../config.jl","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Otherwise run locally, e.g.:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"> sh calibrate_script ../config.jl","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Two parallelized pipelines are able to ingest the config.jl file and perform the calibration, one using Julia's pmap() and another one using parallel bash calls through a SLURM HPC manager. Parallelization is performed over ensemble members. If the ensemble members have to perform several evaluations of TurbulenceConvection.jl, these are performed serially. A fully parallel implementation (global_parallel) that parallelizes across all TurbulenceConvection.jl is included in experiments/SCT1_benchmark.","category":"page"},{"location":"getting_started/#SLURM-HPC-pipeline","page":"Getting started","title":"SLURM HPC pipeline","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"For users with access to a high-performance computing (HPC) cluster, the hpc_parallel may be more efficient. The HPC pipeline parallelizes jobs using different Julia sessions per ensemble member and iteration. Due to the just-in-time compilation nature of Julia, this would normally require compiling the source code again for every new HPC node requested. In order to reduce the compilation overhead, this pipeline builds a system image of EnsembleKalmanProcesses.jl, TurbulenceConvection.jl, CalibrateEDMF.jl and all the functions called in the CalibrateEDMF.jl unit test suite. This system image uses a frozen version of the source code, so it must be re-generated every time any of the precompiled packages is updated or modified by the user.","category":"page"},{"location":"getting_started/#How-to-run-(HPC-pipeline)","page":"Getting started","title":"How to run (HPC pipeline)","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Navigate to experiments/scm_pycles_pipeline/hpc_parallel directory. The master bash script that starts the calibration process is ekp_calibration.sbatch, which takes as an argument the path to the config file.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you are on the Caltech Central Cluster, you can run the project by adding it to the schedule:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"> sbatch ekp_calibration.sbatch ../config.jl","category":"page"},{"location":"getting_started/#Output-of-the-training-pipeline","page":"Getting started","title":"Output of the training pipeline","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"While the simulations run, the results are dumped to a directory named results_... after every iteration of the calibration algorithm. Output of interest is stored in netCDF format, in Diagnostics.nc. To learn more about the diagnostics suite, see the Diagnostics.jl module.","category":"page"},{"location":"API/LESUtils/#LESUtils","page":"LESUtils","title":"LESUtils","text":"","category":"section"},{"location":"API/LESUtils/","page":"LESUtils","title":"LESUtils","text":"CurrentModule = CalibrateEDMF.LESUtils","category":"page"},{"location":"API/LESUtils/","page":"LESUtils","title":"LESUtils","text":"get_les_names\nfind_alias\nget_cfsite_les_dir\nget_LES_library","category":"page"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.get_les_names","page":"LESUtils","title":"CalibrateEDMF.LESUtils.get_les_names","text":"get_les_names(y_names::Vector{String}, filename::String)\nget_les_names(m::ReferenceModel, filename::String)\n\nReturns the aliases of the variables actually present in the nc file (filename) corresponding to SCM variables y_names.\n\n\n\n\n\n","category":"function"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.find_alias","page":"LESUtils","title":"CalibrateEDMF.LESUtils.find_alias","text":"find_alias(aliases::Tuple{Vararg{String}}, filename::String)\n\nFinds the alias present in an NCDataset from a list of possible aliases.\n\n\n\n\n\n","category":"function"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.get_cfsite_les_dir","page":"LESUtils","title":"CalibrateEDMF.LESUtils.get_cfsite_les_dir","text":"get_cfsite_les_dir(\n    cfsite_number::Integer;\n    forcing_model::String = \"HadGEM2-A\",\n    month::Integer = 7,\n    experiment::String = \"amip\",)\n\nGiven information about an LES run from Zhaoyi Shen, Akshay Sridhar, Zhihong Tan, Anna Jaruga, Tapio Schneider (2022), fetch LES directory on central cluster.\n\nInputs:\n\ncfsite_number  :: cfsite number\nforcing_model :: {\"HadGEM2-A\", \"CNRM-CM5\", \"CNRM-CM6-1\", \"IPSL-CM6A-LR\"} - name of climate model used for forcing. Currently, only \"HadGEM2-A\" simulations are available reliably.\nmonth :: {1, 4, 7, 10} - month of simulation.\nexperiment :: {\"amip\", \"amip4K\"} - experiment from which LES was forced.\n\nOutputs:\n\nles_dir - path to les simulation containing stats folder\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#ReferenceModels","page":"ReferenceModels","title":"ReferenceModels","text":"","category":"section"},{"location":"API/ReferenceModels/","page":"ReferenceModels","title":"ReferenceModels","text":"CurrentModule = CalibrateEDMF.ReferenceModels","category":"page"},{"location":"API/ReferenceModels/","page":"ReferenceModels","title":"ReferenceModels","text":"ReferenceModel\nget_ref_model_kwargs\nconstruct_reference_models\ntime_shift_reference_model\nget_z_obs\nget_scm_namelist\nReferenceModelBatch\nget_minibatch!\nreshuffle_on_epoch_end","category":"page"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.ReferenceModel","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.ReferenceModel","text":"ReferenceModel{FT <: Real}\n\nA structure containing information about the 'true' reference model and the observation map used to compare the parameterized and reference models.\n\nFields\n\ny_names::Vector{String}\nVector of reference variable names\ny_dir::String\nDirectory for reference data to compute y mean vector\nΣ_dir::String\nDirectory for reference data to compute Σ covariance matrix\ncase_name::String\nName of case\ny_t_start::Real\nStart time for computing mean statistics over\ny_t_end::Real\nEnd time for computing mean statistics over\nΣ_t_start::Real\nStart time for computing covariance statistics over\nΣ_t_end::Real\nEnd time for computing covariance statistics over\nz_obs::Vector{FT} where FT<:Real\nVector of observed vertical locations\nnamelist::Dict\nTurbulenceConvection namelist\n\nConstructors\n\nReferenceModel(y_names, y_dir, case_name, t_start, t_end; [Σ_dir, Σ_t_start, Σ_t_end, n_obs, namelist_args, seed])\n\nA ReferenceModel can be defined for a case case_name, provided the location of the data, y_dir, the  reference variable names y_names, and the averaging interval (t_start, t_end) is provided.\n\nIf data and/or averaging intervals for the empirical covariance matrix Σ is different than the mean observations y, this is specified with Σ_dir, Σ_t_start, and Σ_t_end.\n\nReferenceModel constructor allowing for any or all of Σ_dir, Σ_t_start, Σ_t_end to be unspecified, in which case they take their values from y_dir, t_start and t_end, respectively.\n\nA tuple of namelist_args can be specified to overwrite default arguments for the case in TurbulenceConvection.jl.\n\nMainly for testing purposes, a seed can also be specified to avoid randomness during namelist generation.\n\n\n\n\n\n","category":"type"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.get_ref_model_kwargs","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.get_ref_model_kwargs","text":"get_ref_model_kwargs(ref_config::Dict; [global_namelist_args])\n\nExtract fields from the reference config necessary to construct ReferenceModels.\n\nThe namelist that defines a case is fetched from TC.jl for each case defined in ref_config[\"case_name\"]. These can be overwritten in one of two ways;\n\nDefine case-by-case overwrite entries in ref_config[\"namelist_args\"]\nDefine global overwrite entries with the keyword argument global_namelist_args (Vector of Tuples).  These entries apply to all cases, training, validation, testing, etc.\n\nNote that the case-by-case namelist_args supersede both TC.jl defaults and global namelist_args entries.\n\nSee also construct_reference_models.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.construct_reference_models","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.construct_reference_models","text":"construct_reference_models(kwarg_ld::Dict{Symbol, Vector; [seed])::Vector{ReferenceModel}\n\nReturns a vector of ReferenceModels given a dictionary of keyword argument lists.\n\nSee also get_ref_model_kwargs.\n\nInputs:\n\nkwarg_ld   :: Dictionary of keyword argument lists\nseed       :: If set, seed is an integer, and is the seed value to generate a TC namelist for each case\n\nOutputs:\n\nref_models :: Vector where the i-th ReferenceModel is constructed from the i-th element of every keyword argument list of the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.time_shift_reference_model","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.time_shift_reference_model","text":"time_shift_reference_model(m::ReferenceModel, Δt::FT) where {FT <: Real}\n\nReturns a time-shifted ReferenceModel, considering an interval relative to the last available time step of the original model.\n\nInputs:\n\nm     :: A ReferenceModel.\nΔt  :: [LES last time - SCM start time (LES timeframe)]\n\nOutputs:\n\nThe time-shifted ReferenceModel.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.get_z_obs","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.get_z_obs","text":"Returns the observed vertical locations for a reference model\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.get_scm_namelist","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.get_scm_namelist","text":"get_scm_namelist(case_name; [y_dir, overwrite, namelist_args, seed])\n\nReturns a TurbulenceConvection.jl namelist, given a case and a list of namelist arguments.\n\nInputs:\n\ncase_name      :: Name of the TurbulenceConvection.jl case considered.\ny_dir          :: Directory with LES data to drive the SCM with, if case_name is LES_driven_SCM.\nnamelist_args  :: Vector of non-default arguments to be used in the namelist, defined as a vector of tuples.\nseed           :: If set, seed is an integer, and is the seed value to generate a TC namelist.\n\nOutputs:\n\nnamelist       :: The TurbulenceConvection.jl namelist.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.ReferenceModelBatch","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.ReferenceModelBatch","text":"struct ReferenceModelBatch\n\nA structure containing a batch of ReferenceModels and an evaluation order for ReferenceModels within the current epoch.\n\nFields\n\nref_models::Vector{CalibrateEDMF.ReferenceModels.ReferenceModel}\nVector containing all reference models\neval_order::Vector{Int64}\nVector of indices defining the ReferenceModel evaluation order when batching\n\nConstructors\n\nReferenceModelBatch(ref_models::Vector{ReferenceModel}, shuffling::Bool = true)\n\nReferenceModelBatch constructor given a vector of ReferenceModels.\n\nReferenceModelBatch(kwarg_ld::Dict{Symbol, Vector{T} where T}, shuffling::Bool = true)\n\nReferenceModelBatch constructor given a dictionary of keyword argument lists.\n\nInputs:\n\nkwarg_ld     :: Dictionary of keyword argument lists\nshuffling    :: Whether to shuffle the order of ReferenceModels.\n\n\n\n\n\n","category":"type"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.get_minibatch!","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.get_minibatch!","text":"get_minibatch!(ref_models::ReferenceModelBatch, batch_size::Int)\n\nReturns a minibatch of ReferenceModels from a ReferenceModelBatch and updates the eval order.\n\nThe size of the minibatch is either the requested size, or the remainder of the elements in the eval_order for this epoch.\n\nInputs:\n\nref_model_batch :: A ReferenceModelBatch.\nbatch_size      :: The number of ReferenceModels to retrieve.\n\nOutputs:\n\nA vector of ReferenceModels.\nThe indices of the returned ReferenceModels.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.reshuffle_on_epoch_end","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.reshuffle_on_epoch_end","text":"Restarts a shuffled evaluation order if the current epoch has finished.\n\n\n\n\n\n","category":"function"},{"location":"#CalibrateEDMF.jl","page":"Home","title":"CalibrateEDMF.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CalibrateEDMF","category":"page"},{"location":"","page":"Home","title":"Home","text":"CalibrateEDMF is a julia package that enables the calibration of atmospheric turbulence and convection parameterizations using gradient-free ensemble Kalman methods. It provides a user-friendly framework to train parameterizations implemented in TurbulenceConvection.jl, using the ensemble-based optimization methods implemented in EnsembleKalmanProcesses.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some of the options enabled by the package are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Automatic regularization of parameter learning as an inverse problem,\nMinibatch training using EnsembleKalmanProcesses.jl,\nKalman inversion with isotropic or anisotropic regularization,\nTracking of validation diagnostics, given a user-specified validation dataset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The rationale behind the calibration framework implemented in this package is thoroughly described in our paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lopez-Gomez, I., Christopoulos, C., Langeland Ervik, H. L., Dunbar, O. R. A., Cohen, Y., Schneider, T. (2022) Training physics-based machine-learning parameterizations with gradient-free ensemble Kalman methods, Journal of Advances in Modeling Earth Systems, 14, e2022MS003105. doi","category":"page"},{"location":"","page":"Home","title":"Home","text":"The manuscript also includes results for an extended eddy-diffusivity mass-flux (EDMF) closure of turbulence and convection trained using this package. If you use this package for your own research, or find any of the ideas presented useful, please cite our work.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CalibrateEDMF.jl is being developed by the Climate Modeling Alliance. The main developers are Ignacio Lopez-Gomez (lead), Haakon Ludvig Langeland Ervik, Charles Kawczynski, Costa Christopoulos and Yair Cohen.","category":"page"}]
}
