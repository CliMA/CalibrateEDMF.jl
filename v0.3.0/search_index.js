var documenterSearchIndex = {"docs":
[{"location":"API/ReferenceStats/#ReferenceStats","page":"ReferenceStats","title":"ReferenceStats","text":"","category":"section"},{"location":"API/ReferenceStats/","page":"ReferenceStats","title":"ReferenceStats","text":"CurrentModule = CalibrateEDMF.ReferenceStats","category":"page"},{"location":"API/ReferenceStats/","page":"ReferenceStats","title":"ReferenceStats","text":"ReferenceStatistics\nget_obs\nobs_PCA\npca\nget_profile\nget_time_covariance","category":"page"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.ReferenceStatistics","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.ReferenceStatistics","text":"ReferenceStatistics{FT <: Real}\n\nA structure containing statistics from the reference model used to define a well-posed inverse problem.\n\nFields\n\ny::Vector{FT} where FT<:Real\nReference data, length: nSim * n_vars * n_zLevels (possibly reduced by PCA)\nΓ::Matrix{FT} where FT<:Real\nData covariance matrix, dims: (y,y) (possibly reduced by PCA)\nnorm_vec::Array{Vector{FT}, 1} where FT<:Real\nVector (length: nSim) of normalizing factors (length: n_vars)\npca_vec::Array{Union{LinearAlgebra.UniformScaling, Matrix{FT}}, 1} where FT<:Real\nVector (length: nSim) of PCA projection matrices with leading eigenvectors as columns\ny_full::Vector{FT} where FT<:Real\nFull reference data vector, length: nSim * n_vars * n_zLevels\nΓ_full::SparseArrays.SparseMatrixCSC{FT, Int64} where FT<:Real\nFull covariance matrix, dims: (y,y)\n\n\n\n\n\n","category":"type"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.get_obs","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.get_obs","text":"get_obs(\n    m::ReferenceModel,\n    y_names::Vector{String},\n    Σ_names::Vector{String},\n    normalize::Bool;\n    z_scm::Union{Vector{FT}, Nothing} = nothing,\n)\n\nGet observations for variables ynames, interpolated to zscm (if given), and possibly normalized with respect to the pooled variance.\n\nInputs:\n\nobs_type     :: Either :les or :scm\nm            :: Reference model\nz_scm        :: If given, interpolate LES observations to given levels.\n\nOutputs:\n\ny            :: Mean of observations, possibly interpolated to z_scm levels.\nΣ            :: Observational covariance matrix, possibly pool-normalized.\npool_var     :: Vector of vertically averaged time-variance, one entry for each variable\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.obs_PCA","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.obs_PCA","text":"obs_PCA(y_mean, y_var, allowed_var_loss = 1.0e-1)\n\nPerform dimensionality reduction using principal component analysis on the variance yvar. Only eigenvectors with eigenvalues that contribute to the leading 1-allowedvar_loss variance are retained. Inputs:\n\ny_mean           :: Mean of the observations.\ny_var            :: Variance of the observations.\nallowed_var_loss :: Maximum variance loss allowed.\n\nOutputs:\n\ny_pca            :: Projection of y_mean onto principal subspace spanned by eigenvectors.\ny_var_pca        :: Projection of y_var on principal subspace.\nP_pca            :: Projection matrix onto principal subspace, with leading eigenvectors as columns.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.pca","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.pca","text":"pca(covmat::AbstractMatrix{FT}, allowed_var_loss::FT) where {FT <: Real}\n\nPerform dimensionality reduction using principal component analysis on the variance covmat.\n\nInputs:\n\ncovmat           :: Variance of the observations.\nallowed_var_loss :: Maximum variance loss allowed.\n\nOutputs:\n\nλ_pca            :: Principal eigenvalues, ordered in increasing value order.\nP_pca            :: Projection matrix onto principal subspace, with leading eigenvectors as columns.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.get_profile","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.get_profile","text":"get_profile(\n    filename::String,\n    var_names::Vector{String};\n    ti::Real = 0.0,\n    tf = nothing,\n    z_scm::Union{Vector{FT}, Nothing} = nothing,\n)\n\nGet profiles for variables varnames, interpolated to zscm (if given), and concatenated into a single output vector.\n\nInputs:\n\nfilename  :: nc filename\nvar_names   :: Names of variables to be retrieved.\nz_scm :: If given, interpolate LES observations to given levels.\n\nOutputs:\n\ny :: Output vector used in the inverse problem, which concatenates the requested profiles.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceStats/#CalibrateEDMF.ReferenceStats.get_time_covariance","page":"ReferenceStats","title":"CalibrateEDMF.ReferenceStats.get_time_covariance","text":"get_time_covariance(m::ReferenceModel, var_names::Vector{String}; z_scm::Vector{FT}) where {FT <: Real}\n\nObtain the covariance matrix of a group of profiles, where the covariance is obtained in time. Inputs:\n\nm            :: Reference model.\nvar_names    :: List of variable names to be included.\nz_scm        :: If given, interpolates covariance matrix to this locations.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#TurbulenceConvectionUtils","page":"TurbulenceConvectionUtils","title":"TurbulenceConvectionUtils","text":"","category":"section"},{"location":"API/TurbulenceConvectionUtils/","page":"TurbulenceConvectionUtils","title":"TurbulenceConvectionUtils","text":"CurrentModule = CalibrateEDMF.TurbulenceConvectionUtils","category":"page"},{"location":"API/TurbulenceConvectionUtils/","page":"TurbulenceConvectionUtils","title":"TurbulenceConvectionUtils","text":"ModelEvaluator\nrun_SCM\nrun_reference_SCM\neval_single_ref_model\nrun_SCM_handler\nget_scm_namelist\ncreate_parameter_vectors\ngenerate_scm_input\nget_gcm_les_uuid\nprecondition","category":"page"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.ModelEvaluator","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.ModelEvaluator","text":"struct ModelEvaluator\n\nA structure containing the information required to perform a forward model evaluation at a given parameter vector.\n\n\n\n\n\n","category":"type"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.run_SCM","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.run_SCM","text":"run_SCM(\n    u::Vector{FT},\n    u_names::Vector{String},\n    RM::Vector{ReferenceModel},\n    RS::ReferenceStatistics;\n    error_check::Bool = false,\n    namelist_args = nothing,\n    failure_handler = \"high_loss\",\n) where {FT <: Real}\n\nRun the single-column model (SCM) using a set of parameters u and return the value of outputs defined in y_names, possibly after normalization and projection onto lower dimensional space using PCA.\n\nInputs:\n\nu               :: Values of parameters to be used in simulations.\nu_names         :: SCM names for parameters u.\nRM              :: Vector of ReferenceModels\nRS              :: reference statistics for simulation\nerror_check     :: Returns as an additional argument whether the SCM call errored.\nnamelist_args   :: Additional arguments passed to the TurbulenceConvection namelist.\nfailure_handler :: Method used to handle failed simulations.\n\nOutputs:\n\nsim_dirs    :: Vector of simulation output directories\ng_scm       :: Vector of model evaluations concatenated for all flow configurations.\ng_scm_pca   :: Projection of g_scm onto principal subspace spanned by eigenvectors.\nmodel_error :: Whether the simulation errored with the requested configuration.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.run_reference_SCM","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.run_reference_SCM","text":"run_reference_SCM(m::ReferenceModel; overwrite::Bool = false)\n\nRun the single-column model (SCM) for a reference model object using default parameters.\n\nInputs:\n\nm                    :: A ReferenceModel.\noverwrite            :: if true, overwrite existing simulation files.\nrun_single_timestep  :: if true, run only one time step.\nnamelist_args        :: Additional arguments passed to the TurbulenceConvection namelist.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.eval_single_ref_model","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.eval_single_ref_model","text":"eval_single_ref_model(\n    m_index::IT,\n    m::ReferenceModel,\n    RS::ReferenceStatistics,\n    u::Vector{FT},\n    u_names::Vector{String},\n    namelist_args = nothing,\n) where {FT <: Real, IT <: Int}\n\nRuns the single-column model (SCM) under a single configuration (i.e., ReferenceModel) using a set of parameters u, and returns the forward model evaluation in both the original and the latent PCA space.\n\nInputs:\n\nm_index       :: The index of the ReferenceModel within the overarching                  ref_models vector used to construct the ReferenceStatistics.\nm             :: A ReferenceModel.\nRS            :: reference statistics for simulation\nu             :: Values of parameters to be used in simulations.\nu_names       :: SCM names for parameters u.\nnamelist_args :: Additional arguments passed to the TurbulenceConvection namelist.\n\nOutputs:\n\nsim_dir     ::  Simulation output directory.\ng_scm       :: Forward model evaluation in original output space.\ng_scm_pca   :: Projection of g_scm onto principal subspace spanned by eigenvectors.\nmodel_error :: Whether the simulation errored with the requested configuration.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.run_SCM_handler","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.run_SCM_handler","text":"run_SCM_handler(\n    m::ReferenceModel,\n    tmpdir::String,\n    u::Array{FT, 1},\n    u_names::Array{String, 1},\n    namelist_args = nothing,\n) where {FT<:AbstractFloat}\n\nRun a case using a set of parameters u_names with values u, and return directory pointing to where data is stored for simulation run.\n\nInputs:\n\nm             :: Reference model\ntmpdir        :: Temporary directory to store simulation results in\nu             :: Values of parameters to be used in simulations.\nu_names       :: SCM names for parameters u.\nnamelist_args :: Additional arguments passed to the TurbulenceConvection namelist.\n\nOutputs:\n\noutput_dir   :: directory containing output data from the SCM run.\nmodel_error   :: Boolean specifying whether the simulation failed.\n\n\n\n\n\nrun_SCM_handler(\n    case_name::String,\n    out_dir::String;\n    u::Vector{FT},\n    u_names::Vector{String},\n    namelist::Union{Dict, Nothing} = nothing,\n    namelist_args::Union{Tuple, Nothing} = nothing,\n    uuid::String = \"01\",\n    les::Union{NamedTuple, String} = nothing,\n)\n\nRun a TurbulenceConvection.jl case and return directory pointing to where data is stored for simulation run.\n\nInputs:\n\ncase_name     :: case name\nout_dir       :: Directory to store simulation results in.\n\nOptional Inputs:\n\nu             :: Values of parameters to be used in simulations.\nu_names       :: SCM names for parameters u.\nnamelist      :: namelist to use for simulation.\nnamelist_args :: Additional arguments passed to the TurbulenceConvection namelist.\nuuid          :: uuid of SCM run\nles           :: path to LES stats file, or NamedTuple with keywords {forcingmodel, month, experiment, cfsitenumber} needed to specify path. \n\nOutputs:\n\noutput_dir   :: directory containing output data from the SCM run.\nmodel_error   :: Boolean specifying whether the simulation failed.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.get_scm_namelist","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.get_scm_namelist","text":"get_scm_namelist(m::ReferenceModel; overwrite::Bool = false)::Dict\n\nFetch the namelist stored in scm_dir(m). Generate a new namelist if it doesn't exist or overwrite=true.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.create_parameter_vectors","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.create_parameter_vectors","text":"create_parameter_vectors(u_names::Vector{String}, u::Vector{FT}) where {FT <: AbstractFloat}\n\nGiven vector of parameter names and corresponding values, combine any vector components into single parameter vectors for input into SCM.\n\nInputs:\n\nu_names :: SCM names for parameters u, which may contain vector components.\nu :: Values of parameters to be used in simulations, which may contain vector components.\n\nOutputs:\n\nu_names_out :: SCM names for parameters u.\nu_out :: Values of parameters to be used in simulations.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.generate_scm_input","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.generate_scm_input","text":"generate_scm_input(\n    model_evaluators::Vector{ModelEvaluator{FT}},\n    outdir_path::String = pwd(),\n) where {FT <: AbstractFloat}\n\nWrites to file a set of ModelEvaluator used to initialize SCM evaluations at different parameter vectors, as well as their assigned numerical version.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.get_gcm_les_uuid","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.get_gcm_les_uuid","text":"get_gcm_les_uuid(\n    cfsite_number::Integer;\n    forcing_model::String,\n    month::Integer,\n    experiment::String,)\n\nGenerate unique and self-describing uuid given information about a GCM-driven LES simulation from Shen et al. 2022.\n\n\n\n\n\n","category":"function"},{"location":"API/TurbulenceConvectionUtils/#CalibrateEDMF.TurbulenceConvectionUtils.precondition","page":"TurbulenceConvectionUtils","title":"CalibrateEDMF.TurbulenceConvectionUtils.precondition","text":"precondition(\n    param::Vector{FT},\n    priors,\n    ref_models::Vector{ReferenceModel},\n    ref_stats::ReferenceStatistics,\n    namelist_args = nothing;\n    counter::Integer = 0,\n    max_counter::Integer = 10,\n) where {FT <: Real}\n\nSubstitute parameter vector param by a parameter vector drawn from the same prior, conditioned on the forward model being stable.\n\nInputs:\n\nparam      :: A parameter vector that may possibly result in unstable  forward model evaluations (in unconstrained space).\npriors      :: Priors from which the parameters were drawn.\nref_models  :: Vector of ReferenceModels to check stability for.\nref_stats   :: ReferenceStatistics of the ReferenceModels.\nnamelist_args :: Arguments passed to the TC.jl namelist.\ncounter :: Accumulator tracking number of recursive calls to preconditioner.\nmax_counter :: Maximum number of recursive calls to the preconditioner.\n\nOutputs:\n\nnew_param  :: A new parameter vector drawn from the prior, conditioned on\n\nsimulations being stable (in unconstrained space).\n\n\n\n\n\nprecondition(ME::ModelEvaluator, priors)\n\nSubstitute the parameter vector of a ModelEvaluator by another one drawn from the given priors, conditioned on the forward model being stable.\n\nInputs:\n\nME          :: A ModelEvaluator.\npriors      :: Priors from which the parameters were drawn.\n\nOutputs:\n\nA preconditioned ModelEvaluator.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#DistributionUtils","page":"DistributionUtils","title":"DistributionUtils","text":"","category":"section"},{"location":"API/DistributionUtils/","page":"DistributionUtils","title":"DistributionUtils","text":"CurrentModule = CalibrateEDMF.DistributionUtils","category":"page"},{"location":"API/DistributionUtils/","page":"DistributionUtils","title":"DistributionUtils","text":"construct_priors\ndeserialize_prior\nflatten_config_dict\nflat_dict_keys_where\nlogmean_and_logstd\nmean_and_std_from_ln","category":"page"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.construct_priors","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.construct_priors","text":"construct_priors(\n    params::Dict{String, Vector{Constraint}};\n    unconstrained_σ::Float64 = 1.0,\n    prior_mean::Union{Vector{Float64}, Nothing} = nothing,\n    outdir_path::String = pwd(),\n    to_file::Bool = true,\n)\n\nDefine a prior Gaussian ParameterDistribution in unconstrained space from a dictionary of constraints.\n\nThis constructor assumes independent priors and the same unconstrained standard deviation for each parameter. Note that the standard deviation in unconstrained space is normalized with respect to the constrained interval width, so it automatically takes into account parameter scales.\n\nThe constructor also allows passing a prior mean for each parameter in constrained space.\n\nInputs:\n\nparams :: Dictionary of parameter names to constraints.\nunconstrained_σ :: Standard deviation of the transformed gaussians (unconstrained space).\nprior_mean :: The mean value of the prior in constrained space. If not given,  the prior is selected to be 0 in unconstrained space.\noutdir_path :: Output path.\nto_file :: Whether to write the serialized prior to a JLD2 file.\n\nOutput:\n\nThe prior ParameterDistribution.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.deserialize_prior","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.deserialize_prior","text":"deserialize_prior(prior_dict::Dict{String, Any})\n\nGenerates a prior ParameterDistribution from arguments stored in a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.flatten_config_dict","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.flatten_config_dict","text":"flatten_config_dict(param_dict::Dict{String, Vector{T}})\n\nGiven a dictionary of parameter names to parameter vectors of arbitrary length, return a new dictionary that maps a unique parameter name to each element of the full flattened vector of parameters.\n\nInputs:\n\nparam_dict :: Dictionary of parameter names to constraints.\n\nOutputs:\n\nu_names :: Vector{String} :: vector of parameter names\nvalues :: Vector{Vector{T}} :: vector of single-valued vectors encapsulating parameter values.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.flat_dict_keys_where","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.flat_dict_keys_where","text":"flat_dict_keys_where(dict::Dict{String, Vector{T}}, condition::Function = identity) where {T}\n\nFlattens the values of a dictionary with parameter vectors as keys, and returns the indices of entries in the flattened dictionary satisfying a given condition.\n\nInputs:     param_dict :: Dictionary of parameter names to vectors.     condition :: A condition function operating on each dictionary value. Outputs:     Indices of flattened entries satisfying the condition.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.logmean_and_logstd","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.logmean_and_logstd","text":"logmean_and_logstd(μ, σ)\n\nReturns the lognormal parameters μ and σ from the mean μ and std σ of the lognormal distribution.\n\n\n\n\n\n","category":"function"},{"location":"API/DistributionUtils/#CalibrateEDMF.DistributionUtils.mean_and_std_from_ln","page":"DistributionUtils","title":"CalibrateEDMF.DistributionUtils.mean_and_std_from_ln","text":"mean_and_std_from_ln(μ, σ)\n\nReturns the mean and variance of the lognormal distribution from the lognormal parameters μ and σ.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"CurrentModule = CalibrateEDMF.Diagnostics","category":"page"},{"location":"API/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"io_dictionary_metrics\nio_dictionary_particle_state\nio_dictionary_particle_eval\nio_dictionary_prior\nget_ϕ_cov","category":"page"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_metrics","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_metrics","text":"io_dictionary_metrics()\n\nScalar metrics dictionary.\n\nElements:\n\nloss_mean_g :: (ḡ - y)'Γ_inv(ḡ - y).\nmse_full_mean :: Ensemble mean of MSE(g_full, y_full).\nmse_full_min :: Ensemble min of MSE(g_full, y_full).\nmse_full_max :: Ensemble max of MSE(g_full, y_full).\nmse_full_var :: Variance estimate of MSE(g_full, y_full), empirical (EKI/EKS) or quadrature (UKI).\nmse_full_nn_mean :: MSE(g_full, y_full) of particle closest to the mean in parameter space. The mean in parameter space is the solution to the particle-based inversion.\nfailures :: Number of particle failures per iteration. If the calibration is run with the \"high_loss\" failure handler, this diagnostic will not capture the failures.\nnn_mean_index :: Particle index of the nearest neighbor to the ensemble mean in parameter space.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_particle_state","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_particle_state","text":"io_dictionary_particle_state()\n\nDictionary of particle-wise parameter diagnostics, not involving forward model evaluations.\n\nElements:\n\nu   :: Parameters in unconstrained (inverse problem) space.\nphi :: Parameters in constrained (physical) space.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_particle_eval","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_particle_eval","text":"io_dictionary_particle_eval()\n\nDictionary of particle-wise parameter diagnostics involving forward model evaluations.\n\nElements:\n\ng :: Forward model evaluation in inverse problem space.\ng_full :: Forward model evaluation in primitive output space, normalized using the pooled field covariance.\nmse_full :: Particle-wise evaluation of MSE(g_full, y_full).\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.io_dictionary_prior","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.io_dictionary_prior","text":"io_dictionary_prior()\n\nParameter prior diagnostics dictionary.\n\nElements:\n\nu_mean_prior :: Prior mean in unconstrained parameter space.\nphi_mean_prior :: Prior mean in constrained parameter space.\nu_var_prior :: Diagonal of the prior covariance in unconstrained space.\nphi_low_unc_prior :: Lower uncertainty bound (μ-1σ_prior) of prior in constrained space.\nphi_upp_unc_prior :: Upper uncertainty bound (μ+1σ_prior) of prior in constrained space.\nphi_low_std_prior :: Lower standard bound (μ-1) of prior in constrained space. Useful measure of minimum allowed values for bounded parameters.\nphi_upp_std_prior :: Upper standard bound (μ+1) of prior in constrained space. Useful measure of maximum allowed values for bounded parameters.\n\n\n\n\n\n","category":"function"},{"location":"API/Diagnostics/#CalibrateEDMF.Diagnostics.get_ϕ_cov","page":"Diagnostics","title":"CalibrateEDMF.Diagnostics.get_ϕ_cov","text":"get_ϕ_cov(ekp::EnsembleKalmanProcess, priors::ParameterDistribution)\n\nGet the last parameter covariance estimate in constrained (physical) space.\n\nFor ensemble methods, the covariance of the transformed parameters is returned. For unscented methods, the covariance is computed through a quadrature on the transformed quadrature points. The covariance of the transformed parameters returned here is equal to the transformed covariance only under a first order Taylor approximation, which is consistent with other approximations underlying the calibration method.\n\nInputs:\n\nekp    :: The EnsembleKalmanProcess.\npriors :: The priors defining transformations between constrained and unconstrained space.\n\nOutputs:\n\nThe parameter covariance in constrained space.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#HelperFuncs","page":"HelperFuncs","title":"HelperFuncs","text":"","category":"section"},{"location":"API/HelperFuncs/","page":"HelperFuncs","title":"HelperFuncs","text":"CurrentModule = CalibrateEDMF.HelperFuncs","category":"page"},{"location":"API/HelperFuncs/","page":"HelperFuncs","title":"HelperFuncs","text":"vertical_interpolation\nnc_fetch_interpolate\nfetch_interpolate_transform\nget_height\nget_dz\nnormalize_profile\nnc_fetch\nis_face_variable\nget_stats_path\ncompute_mse\npenalize_nan\nserialize_struct\ndeserialize_struct\njld2_path\nwrite_versions\nget_entry\nchange_entry!","category":"page"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.vertical_interpolation","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.vertical_interpolation","text":"vertical_interpolation(\n    var_name::String,\n    filename::String,\n    z_scm::Vector{FT};\n) where {FT <: AbstractFloat}\n\nReturns the netcdf variable varname interpolated to heights zscm.\n\nInputs:\n\nvar_name :: Name of variable in the netcdf dataset.\nfilename :: nc filename\nz_scm :: Vertical coordinate vector onto which var_name is interpolated.\n\nOutput:\n\nThe interpolated vector.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.nc_fetch_interpolate","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.nc_fetch_interpolate","text":"nc_fetch_interpolate(\n    var_name::String,\n    filename::String,\n    z_scm::Union{Vector{Float64}, Nothing};\n)\n\nReturns the netcdf variable varname, possibly interpolated to heights zscm.\n\nInputs:\n\nvar_name :: Name of variable in the netcdf dataset.\nfilename :: nc filename\nz_scm :: Vertical coordinate vector onto which var_name is interpolated.\n\nOutput:\n\nThe interpolated vector.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.fetch_interpolate_transform","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.fetch_interpolate_transform","text":"fetch_interpolate_transform(\n    var_name::String,\n    filename::String,\n    z_scm::Union{Vector{Float64}, Nothing};\n)\n\nReturns the netcdf variable varname, possibly interpolated to heights zscm. If the variable needs to be transformed to be equivalent to an SCM variable, applies the transformation as well.\n\nInputs:\n\nvar_name :: Name of variable in the netcdf dataset.\nfilename :: nc filename\nz_scm :: Vertical coordinate vector onto which var_name is interpolated.\n\nOutput:\n\nThe interpolated and transformed vector.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.get_height","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.get_height","text":"get_height(filename::String; get_faces::Bool = false)\n\nReturns the vertical cell centers or faces of the given configuration.\n\nInputs:\n\nfilename :: nc filename.\nget_faces :: If true, returns the coordinates of cell faces. Otherwise,  returns the coordinates of cell centers.\n\nOutput:\n\nz: Vertical level coordinates.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.get_dz","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.get_dz","text":"get_dz(filename::String)\n\nReturns the vertical grid size of the given configuration.\n\nInputs:\n\nfilename :: nc filename\n\nOutput:\n\nThe vertical grid size.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.normalize_profile","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.normalize_profile","text":"normalize_profile(profile_vec, n_vars, var_vec)\n\nPerform normalization of nvars profiles contained in profilevec using the variance associated with each variable, contained in var_vec.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.nc_fetch","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.nc_fetch","text":"nc_fetch(filename::String, var_names::NTuple{N, Tuple}) where {N}\nnc_fetch(filename::String, var_name::String)\n\nReturns the data for a variable var_name (or tuple of strings, varnames), looping through all dataset groups.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.is_face_variable","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.is_face_variable","text":"is_face_variable(filename::String, var_name::String)\n\nA Bool indicating whether the given variables is defined in faces, or not.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.get_stats_path","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.get_stats_path","text":"get_stats_path(dir)\n\nGiven directory to standard LES or SCM output, fetch path to stats file.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.compute_mse","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.compute_mse","text":"compute_mse(g_arr::Vector{Vector{FT}}, y::Vector{FT})::Vector{FT}\ncompute_mse(g_mat::Matrix{FT}, y::Vector{FT})::Vector{FT}\n\nComputes the L2-norm error of each vector, column or row of an array with respect to a vector y.\n\nOutput:\n\nThe mse for each ensemble member.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.penalize_nan","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.penalize_nan","text":"penalize_nan(arr::Vector{FT}; penalization::FT = 1.0e5) where {FT <: AbstractFloat}\n\nSubstitutes all NaN entries in arr by a penalization factor.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.serialize_struct","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.serialize_struct","text":"serialize_struct(s::T) where {T}\n\nSerializes the given structure as a dictionary to allow storage in JLD2 format.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.deserialize_struct","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.deserialize_struct","text":"deserialize_struct(dict::Dict{String}, ::Type{T})\n\nDeserializes the given dictionary and constructs a struct of the given type with the dictionary values.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.jld2_path","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.jld2_path","text":"jld2_path(root::String, identifier::Union{String, Int}, prefix::String)\n\nGenerates a JLD2 path, given a root path, an identifier and a prefix.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.write_versions","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.write_versions","text":"write_versions(versions::Vector{Int}, iteration::Int; outdir_path::String = pwd())\n\nWrites versions associated with an EnsembleKalmanProcess iteration to a text file.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.get_entry","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.get_entry","text":"get_entry(dict, key, default)\n\nCalls get but logs whether the default is used.\n\n\n\n\n\n","category":"function"},{"location":"API/HelperFuncs/#CalibrateEDMF.HelperFuncs.change_entry!","page":"HelperFuncs","title":"CalibrateEDMF.HelperFuncs.change_entry!","text":"change_entry!(dict, keys_and_value)\n\nChanges the entry of a nested dictionary, giving a tuple of all its keys and the new value\n\nInputs:\n\ndict           :: Parent dictionary with an arbitrary number of nested dictionaries.\nkeys_and_value :: Tuple of keys from the parent dictionary to the entry to be modified,                   and the value to use to modify it.\n\n\n\n\n\n","category":"function"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"","category":"page"},{"location":"API/Pipeline/#Pipeline","page":"Pipeline","title":"Pipeline","text":"","category":"section"},{"location":"API/Pipeline/","page":"Pipeline","title":"Pipeline","text":"CurrentModule = CalibrateEDMF.Pipeline","category":"page"},{"location":"API/Pipeline/","page":"Pipeline","title":"Pipeline","text":"init_calibration\nrestart_calibration\nek_update\nupdate_validation\nupdate_minibatch_inverse_problem\nwrite_model_evaluators\ninit_diagnostics\nupdate_diagnostics","category":"page"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.init_calibration","page":"Pipeline","title":"CalibrateEDMF.Pipeline.init_calibration","text":"init_calibration(job_id::String, config::Dict{Any, Any})\n\nInitializes a calibration process given a configuration, and a pipeline mode.\n\nInputs:\n\njob_id :: Unique job identifier for sbatch communication.\nconfig :: User-defined configuration dictionary.\nmode :: Whether the calibration process is parallelized through HPC resources or using Julia's pmap.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.restart_calibration","page":"Pipeline","title":"CalibrateEDMF.Pipeline.restart_calibration","text":"restart_calibration(\n    ekobj::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    last_iteration::Int64,\n    config::Dict{Any, Any},\n    outdir_path::String,\n)\n\nRestarts a calibration process from an EnsembleKalmanProcess, the parameter priors and the calibration process config file. If batching, it requires access to the last ReferenceModelBatch, stored in the results directory of the previous calibration, outdir_path.\n\nWrites to file the ModelEvaluators necessary to continue the calibration process.\n\nInputs:\n\nekobj          :: EnsembleKalmanProcess to be updated.\npriors         :: Priors over parameters, used for unconstrained-constrained mappings.\nlast_iteration :: Last iteration of the calibration process to be restarted.\nconfig         :: Configuration dictionary.\noutdir_path    :: Output path directory of the calibration process to be restarted.\nmode :: Whether the calibration process is parallelized through HPC resources or using Julia's pmap.\njob_id :: Unique job identifier for sbatch communication.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.ek_update","page":"Pipeline","title":"CalibrateEDMF.Pipeline.ek_update","text":"ek_update(\n    ekobj::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    iteration::Int64,\n    config::Dict{Any, Any},\n    versions::Vector{String},\n    outdir_path::String,\n)\n\nUpdates an EnsembleKalmanProcess using forward model evaluations stored in output files defined by their versions, and generates the parameters for the next ensemble for forward model evaluations. The updated EnsembleKalmanProcess and new ModelEvaluators are both written to file.\n\nInputs:\n\nekobj         :: EnsembleKalmanProcess to be updated.\npriors        :: Priors over parameters, used for unconstrained-constrained mappings.\niteration     :: Current iteration of the calibration process.\nconfig        :: Process configuration dictionary.\nversions      :: String versions identifying the forward model evaluations.\noutdir_path   :: Output path directory.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.update_validation","page":"Pipeline","title":"CalibrateEDMF.Pipeline.update_validation","text":"update_validation(\n    val_config::Dict{Any, Any},\n    reg_config::Dict{Any, Any},\n    ekp_old::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    versions::Vector{String},\n    outdir_path::String,\n    iteration::IT\n    )\n\nUpdates the validation diagnostics and writes to file the validation ModelEvaluators for the next calibration step.\n\nInputs:\n\nval_config    :: Validation model configuration.\nreg_config    :: Regularization configuration.\nekp_old       :: EnsembleKalmanProcess updated using the past forward model evaluations.\npriors        :: The priors over parameter space.\nversions      :: String versions identifying the forward model evaluations.\noutdir_path   :: Output path directory.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.update_minibatch_inverse_problem","page":"Pipeline","title":"CalibrateEDMF.Pipeline.update_minibatch_inverse_problem","text":"update_minibatch_inverse_problem(\n    rm_batch::ReferenceModelBatch,\n    ekp_old::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    batch_size::Integer,\n    outdir_path::String,\n    config::Dict{Any, Any},\n)\n\nReturns the EnsembleKalmanProcess and ReferenceStatistics consistent with the new ReferenceModel minibatch, and updates the evaluation order of the ReferenceModelBatch.\n\nInputs:\n\nrm_batch    :: The global ReferenceModelBatch with the current model evaluation order.\nekp_old     :: The EnsembleKalmanProcess from the previous minibatch evaluation.\nbatch_size  :: The batch size of the current minibatch.\noutdir_path :: The output directory.\nconfig      :: The configuration dictionary.\n\nOutputs:\n\nekp             :: The EnsembleKalmanProcess for the current minibatch.\nref_models      :: The current minibatch of ReferenceModels.\nref_stats       :: The ReferenceStatistics consistent with the current minibatch.\nrefmodelbatch :: The global ReferenceModelBatch with the updated model evaluation order.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.write_model_evaluators","page":"Pipeline","title":"CalibrateEDMF.Pipeline.write_model_evaluators","text":"write_model_evaluators(\n    ekp::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n    ref_models::Vector{ReferenceModel},\n    ref_stats::ReferenceStatistics,\n    outdir_path::String,\n    iteration::Int,\n)\n\nCreates and writes to file the ModelEvaluators for the current particle ensemble.\n\nInputs:\n\nekp         :: The EnsembleKalmanProcess with the current ensemble of parameter values.\npriors      :: The parameter priors.\nref_models  :: The ReferenceModels defining the new model evaluations.\nref_stats   :: The ReferenceStatistics corresponding to passed ref_models.\noutdir_path :: The output directory.\niteration   :: The current process iteration.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.init_diagnostics","page":"Pipeline","title":"CalibrateEDMF.Pipeline.init_diagnostics","text":"init_diagnostics(\n    config::Dict{Any, Any},\n    outdir_path::String,\n    ref_stats::ReferenceStatistics,\n    ekp::EnsembleKalmanProcess,\n    priors::ParameterDistribution,\n)\n\nCreates a diagnostics netcdf file.\n\nInputs:\n\nconfig :: User-defined configuration dictionary.\noutdir_path :: Path of results directory.\nref_stats :: ReferenceStatistics.\nekp :: Initial EnsembleKalmanProcess, containing parameter information, but no forward model evaluations.\npriors:: Prior distributions of the parameters.\n\n\n\n\n\n","category":"function"},{"location":"API/Pipeline/#CalibrateEDMF.Pipeline.update_diagnostics","page":"Pipeline","title":"CalibrateEDMF.Pipeline.update_diagnostics","text":"update_diagnostics(outdir_path::String, ekp::EnsembleKalmanProcess, priors::ParameterDistribution)\n\nAppends diagnostics of the current iteration evaluations (i.e., forward model output metrics) and the next iteration state (i.e., parameters and parameter metrics) to a diagnostics netcdf file.\n\nInputs:\n\noutdir_path :: Path of results directory.\nekp :: Current EnsembleKalmanProcess.\npriors:: Prior distributions of the parameters.\nref_stats :: ReferenceStatistics.\ng_full :: The forward model evaluation in primitive space.\nversions :: Version identifiers of the forward model evaluations at the current iteration.\nval_config :: The validation configuration, if given.\nbatch_indices :: The indices of the ReferenceModels used in the current batch.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#KalmanProcessUtils","page":"KalmanProcessUtils","title":"KalmanProcessUtils","text":"","category":"section"},{"location":"API/KalmanProcessUtils/","page":"KalmanProcessUtils","title":"KalmanProcessUtils","text":"CurrentModule = CalibrateEDMF.KalmanProcessUtils","category":"page"},{"location":"API/KalmanProcessUtils/","page":"KalmanProcessUtils","title":"KalmanProcessUtils","text":"generate_ekp\ngenerate_tekp\nget_sparse_indices\nget_regularized_indices","category":"page"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.generate_ekp","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.generate_ekp","text":"generate_ekp(\n    ref_stats::ReferenceStatistics,\n    process::Process,\n    u::Union{Matrix{T}, T} = nothing;\n    failure_handler::String = \"ignore_failures\",\n    outdir_path::String = pwd(),\n    to_file::Bool = true,\n) where {T}\n\nGenerates, and possible writes to file, an EnsembleKalmanProcess from a parameter ensemble and reference statistics.\n\nInputs:\n\nref_stats :: ReferenceStatistics defining the inverse problem.\nprocess :: Type of EnsembleKalmanProcess used to evolve the ensemble.\nu :: An ensemble of parameter vectors, used if !isa(process, Unscented).\nfailure_handler :: String describing what failure handler to use.\noutdir_path :: Output path.\nto_file :: Whether to write the serialized prior to a JLD2 file.\n\nOutput:\n\nThe generated EnsembleKalmanProcess.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.generate_tekp","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.generate_tekp","text":"generate_tekp(\n    ref_stats::ReferenceStatistics,\n    priors::ParameterDistribution,\n    process::Process,\n    u::Union{Matrix{T}, T} = nothing;\n    l2_reg::Union{Dict{String, Vector{R}}, R} = nothing,\n    failure_handler::String = \"ignore_failures\",\n    outdir_path::String = pwd(),\n    to_file::Bool = true,\n) where {T, R}\n\nGenerates, and possible writes to file, a Tikhonov EnsembleKalmanProcess from a parameter ensemble and reference statistics.\n\nTikhonov regularization is implemented through output state augmentation with the input parameter vector. The input L2 regularization hyperparameter should be interpreted as the inverse of the variance of our prior belief in the magnitude of the parameters.\n\nInputs:\n\nref_stats :: ReferenceStatistics defining the inverse problem.\npriors :: Parameter priors used for L2 (i.e., Tikhonov) regularization\nprocess :: Type of EnsembleKalmanProcess used to evolve the ensemble.\nu :: An ensemble of parameter vectors, used if !isa(process, Unscented).\nl2_reg :: L2 regularization hyperparameter driving parameter values toward prior.      May be a float (isotropic regularization) or a dictionary of regularizations      per parameter.\nfailure_handler :: String describing what failure handler to use.\noutdir_path :: Output path.\nto_file :: Whether to write the serialized prior to a JLD2 file.\n\nOutput:\n\nThe generated augmented EnsembleKalmanProcess.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.get_sparse_indices","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.get_sparse_indices","text":"Returns the sparse parameter indices given the sparsity configuration and the number of parameters.\n\n\n\n\n\n","category":"function"},{"location":"API/KalmanProcessUtils/#CalibrateEDMF.KalmanProcessUtils.get_regularized_indices","page":"KalmanProcessUtils","title":"CalibrateEDMF.KalmanProcessUtils.get_regularized_indices","text":"Returns the indices of parameters to be regularized, given the l2 regularization configuration dictionary.\n\n\n\n\n\n","category":"function"},{"location":"API/LESUtils/#LESUtils","page":"LESUtils","title":"LESUtils","text":"","category":"section"},{"location":"API/LESUtils/","page":"LESUtils","title":"LESUtils","text":"CurrentModule = CalibrateEDMF.LESUtils","category":"page"},{"location":"API/LESUtils/","page":"LESUtils","title":"LESUtils","text":"get_les_names\nfind_alias\nget_cfsite_les_dir\nget_LES_library","category":"page"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.get_les_names","page":"LESUtils","title":"CalibrateEDMF.LESUtils.get_les_names","text":"get_les_names(y_names::Vector{String}, filename::String)\nget_les_names(m::ReferenceModel, filename::String)\n\nReturns the aliases of the variables actually present in the nc file (filename) corresponding to SCM variables y_names.\n\n\n\n\n\n","category":"function"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.find_alias","page":"LESUtils","title":"CalibrateEDMF.LESUtils.find_alias","text":"find_alias(aliases::Tuple{Vararg{String}}, filename::String)\n\nFinds the alias present in an NCDataset from a list of possible aliases.\n\n\n\n\n\n","category":"function"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.get_cfsite_les_dir","page":"LESUtils","title":"CalibrateEDMF.LESUtils.get_cfsite_les_dir","text":"get_cfsite_les_dir(\n    cfsite_number::Integer;\n    forcing_model::String = \"HadGEM2-A\",\n    month::Integer = 7,\n    experiment::String = \"amip\",)\n\nGiven information about an LES run from Zhaoyi Shen, Akshay Sridhar, Zhihong Tan, Anna Jaruga, Tapio Schneider (2022), fetch LES directory on central cluster.\n\nInputs:\n\ncfsite_number  :: cfsite number\nforcing_model :: {\"HadGEM2-A\", \"CNRM-CM5\", \"CNRM-CM6-1\", \"IPSL-CM6A-LR\"} - name of climate model used for forcing. Currently, only \"HadGEM2-A\" simulations are available reliably.\nmonth :: {1, 4, 7, 10} - month of simulation.\nexperiment :: {\"amip\", \"amip4K\"} - experiment from which LES was forced.\n\nOutputs:\n\nles_dir - path to les simulation containing stats folder\n\n\n\n\n\n","category":"function"},{"location":"API/LESUtils/#CalibrateEDMF.LESUtils.get_LES_library","page":"LESUtils","title":"CalibrateEDMF.LESUtils.get_LES_library","text":"get_LES_library\n\nHierarchical dictionary of available LES simulations described in Zhaoyi Shen, Akshay Sridhar, Zhihong Tan, Anna Jaruga, Tapio Schneider (2022). The following cfsites are available across listed models, months, and experiments.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#ReferenceModels","page":"ReferenceModels","title":"ReferenceModels","text":"","category":"section"},{"location":"API/ReferenceModels/","page":"ReferenceModels","title":"ReferenceModels","text":"CurrentModule = CalibrateEDMF.ReferenceModels","category":"page"},{"location":"API/ReferenceModels/","page":"ReferenceModels","title":"ReferenceModels","text":"ReferenceModel\nconstruct_reference_models\ntime_shift_reference_model\nget_z_obs\nReferenceModelBatch\nget_minibatch!\nreshuffle_on_epoch_end","category":"page"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.ReferenceModel","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.ReferenceModel","text":"ReferenceModel\n\nA structure containing information about the 'true' reference model and the observation map used to compare the parameterized and reference models.\n\nFields\n\ny_names::Vector{String}\nVector of reference variable names\ny_dir::String\nDirectory for reference data to compute y mean vector\nΣ_dir::String\nDirectory for reference data to compute Σ covariance matrix\nscm_dir::String\nDirectory for static data related to forward scm model (parameter file & vertical levels)\ncase_name::String\nName of case\ny_t_start::Real\nStart time for computing mean statistics over\ny_t_end::Real\nEnd time for computing mean statistics over\nΣ_t_start::Real\nStart time for computing covariance statistics over\nΣ_t_end::Real\nEnd time for computing covariance statistics over\nn_obs::Union{Nothing, Integer}\nNumber of observed vertical locations, if not the native grid\n\n\n\n\n\n","category":"type"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.construct_reference_models","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.construct_reference_models","text":"construct_reference_models(kwarg_ld::Dict{Symbol, Vector{T} where T})::Vector{ReferenceModel}\n\nReturns a vector of ReferenceModels given a dictionary of keyword argument lists.\n\nInputs:\n\nkwarg_ld     :: Dictionary of keyword argument lists\n\nOutputs:\n\nref_models   :: Vector where the i-th ReferenceModel is constructed from the i-th element of every keyword argument list of the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.time_shift_reference_model","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.time_shift_reference_model","text":"time_shift_reference_model(m::ReferenceModel, Δt::FT) where {FT <: Real}\n\nReturns a time-shifted ReferenceModel, considering an interval relative to the last available time step of the original model.\n\nInputs:\n\nm     :: A ReferenceModel.\nΔt  :: [LES last time - SCM start time (LES timeframe)]\n\nOutputs:\n\nThe time-shifted ReferenceModel.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.get_z_obs","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.get_z_obs","text":"Returns the observed vertical locations for a reference model\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.ReferenceModelBatch","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.ReferenceModelBatch","text":"struct ReferenceModelBatch\n\nA structure containing a batch of ReferenceModels and a mutable evaluation order for ReferenceModels within the current epoch.\n\n\n\n\n\n","category":"type"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.get_minibatch!","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.get_minibatch!","text":"get_minibatch!(ref_models::ReferenceModelBatch, batch_size::Int)\n\nReturns a minibatch of ReferenceModels from a ReferenceModelBatch and updates the eval order.\n\nThe size of the minibatch is either the requested size, or the remainder of the elements in the eval_order for this epoch.\n\nInputs:\n\nref_model_batch :: A ReferenceModelBatch.\nbatch_size      :: The number of ReferenceModels to retrieve.\n\nOutputs:\n\nA vector of ReferenceModels.\nThe indices of the returned ReferenceModels.\n\n\n\n\n\n","category":"function"},{"location":"API/ReferenceModels/#CalibrateEDMF.ReferenceModels.reshuffle_on_epoch_end","page":"ReferenceModels","title":"CalibrateEDMF.ReferenceModels.reshuffle_on_epoch_end","text":"Restarts a shuffled evaluation order if the current epoch has finished.\n\n\n\n\n\n","category":"function"},{"location":"#CalibrateEDMF.jl","page":"Home","title":"CalibrateEDMF.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CalibrateEDMF","category":"page"},{"location":"","page":"Home","title":"Home","text":"CalibrateEDMF is a julia package that enables the calibration of atmospheric turbulence and convection parameterizations using gradient-free ensemble Kalman methods. It provides a user-friendly framework to train parameterizations implemented in TurbulenceConvection.jl, using the ensemble-based optimization methods implemented in EnsembleKalmanProcesses.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some of the options enabled by the package are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Automatic regularization of parameter learning as an inverse problem,\nMinibatch training using EnsembleKalmanProcesses.jl,\nKalman inversion with isotropic or anisotropic regularization,\nTracking of validation diagnostics, given a user-specified validation dataset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The rationale behind the calibration framework implemented in this package is thoroughly described in our preprint:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lopez-Gomez, I., Christopoulos, C., Langeland Ervik, H. L., Dunbar, O. R. A., Cohen, Y., Schneider, T. (2022) Training physics-based machine-learning parameterizations with gradient-free ensemble Kalman methods. preprint","category":"page"},{"location":"","page":"Home","title":"Home","text":"The manuscript also includes results for an extended eddy-diffusivity mass-flux (EDMF) closure of turbulence and convection trained using this package. If you use this package for your own research, or find any of the ideas presented useful, please cite our work.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CalibrateEDMF.jl is being developed by the Climate Modeling Alliance. The main developers are Ignacio Lopez-Gomez (lead), Haakon Ludvig Langeland Ervik, Charles Kawczynski, Costa Christopoulos and Yair Cohen.","category":"page"}]
}
